{"title":"Part-of-Speech Tagging and Dependency Parsing","markdown":{"headingText":"Part-of-Speech Tagging and Dependency Parsing","containsRefs":false,"markdown":"\n\n\nIn the previous lab, we worked with keyness and effect sizes, specifically using log-likelihood and log ratio measures.\n\nWe are now going to add to our toolkit by using the same measures, but applied to data that has been tagged and parsed. To our processing pipeline, we will be adding **udpipe**: <https://bnosac.github.io/udpipe/en/>\n\n## What does udpipe do?\n\nBefore we start processing in R, let's get some sense of what \"universal dependency parsing\" is and what its output looks like.\n\n### Parse a sample sentence online\n\nGo to this webpage: <http://lindat.mff.cuni.cz/services/udpipe/>. \n\nAnd paste the following sentence into the text field:\n\n> The company offers credit cards, loans and interest-generating accounts.\n\nThen, click the \"Process Input\" button. You should now see an output. If you choose the \"Table\" tab, you can view the output in a tablular format.\n\n### Basic parse structure\n\nThere is a column for the **token** and one for the token's base form or **lemma**.\n\nThose are followed by a tag for the general lexical class or \"universal part-of-speech\" (**upos**) tag, and a tree-bank specific (**xpos**) part-of-speech tag.\n\nThe **xpos** tags are Penn Treebank tags, which you can find here: <https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html>\n\nThe part-of-speech tags are followed by a column of integers that refer to the id of the token that is at the head of the dependency structure, which is followed by the **dependency relation** identifier.\n\nFor a list of all dependency abbreviaitons see here: <https://universaldependencies.org/u/dep/index.html>. \n\n### Visualize the dependency\n\nFrom the \"Output Text\" tab, copy the output start with the **sent_id** including the pound sign\n\nPaste the information into the text field here: <https://urd2.let.rug.nl/~kleiweg/conllu/>. Then click the \"Submit Query\" button below the text field. This should generate a visualization of the dependency structure.\n\n## Load the needed packages \n\n```{r}\n#| message: false\n#| error: false\n#| warning: false\n\nlibrary(tidyverse)\nlibrary(quanteda)\nlibrary(quanteda.textstats)\nlibrary(udpipe)\nlibrary(gt)\n```\n\nLoad the functions:\n\n```{r}\nsource(\"../R/keyness_functions.R\")\n```\n\nLoad the data:\n\n\n```{r}\nload(\"../data/sample_corpus.rda\")\n```\n\n\n## Parsing\n\n### Preparing a corpus\n\nWhen we parse texts using a model like ones available in **udpipe** or **spacy**, we need to do very little to prepare the corpus. We could trim extra spaces and returns using **str_squish()** or remove urls, but generally we want the text to be mostly \"as is\" so the model can do its job.\n\n### Download a model\n\nYou only need to run this line of code **once**. To run it, remove the pound sign, run the line, then add the pound sign after you've downloaded the model. Or you can run the next chunk and the model will automatically be downloaded in your working directory.\n\n```{r download_model}\n# udpipe_download_model(language = \"english\")\n```\n\n### Annotate a sentence\n\n```{r}\n#| message: false\n#| warning: false\n\ntxt <- \"The company offers credit cards, loans and interest-generating accounts.\"\nud_model <- udpipe_load_model(\"../models/english-ewt-ud-2.5-191206.udpipe\")\nannotation <- udpipe(txt, ud_model)\n```\n\n\n```{r}\n#| code-fold: true\n#| tbl-cap: \"Annotation of a sample sentence.\"\n\nannotation[,8:15] |>\n  gt() |>\n  as_raw_html()\n```\n\n### Plot the annotation\n\nWe can also plot the dependency structure using **igraph**:\n\n```{r}\n#| message: false\n#| warning: false\n#| error: false\n\nlibrary(igraph)\nlibrary(ggraph)\n```\n\nFirst we'll create a plotting function.\n\n```{r}\nplot_annotation <- function(x, size = 3){\n  stopifnot(is.data.frame(x) & all(c(\"sentence_id\", \"token_id\", \"head_token_id\", \"dep_rel\",\n                                     \"token_id\", \"token\", \"lemma\", \"upos\", \"xpos\", \"feats\") %in% colnames(x)))\n  x <- x[!is.na(x$head_token_id), ]\n  x <- x[x$sentence_id %in% min(x$sentence_id), ]\n  edges <- x[x$head_token_id != 0, c(\"token_id\", \"head_token_id\", \"dep_rel\")]\n  edges <- edges[edges$dep_rel != \"punct\",]\n  edges$head_token_id <- ifelse(edges$head_token_id == 0, edges$token_id, edges$head_token_id)\n  nodes = x[, c(\"token_id\", \"token\", \"lemma\", \"upos\", \"xpos\", \"feats\")]\n  edges$label <- edges$dep_rel\n  g <- graph_from_data_frame(edges,\n                             vertices = nodes,\n                             directed = TRUE)\n  ggraph(g, layout = \"linear\") +\n    geom_edge_arc(ggplot2::aes(label = dep_rel, vjust = -0.20), fold = T,linemitre = 2,\n                  arrow = grid::arrow(length = unit(3, 'mm'), ends = \"last\", type = \"closed\"),\n                  end_cap = ggraph::label_rect(\"wordswordswords\"),\n                  label_colour = \"red\", check_overlap = TRUE, label_size = size) +\n    geom_node_label(ggplot2::aes(label = token), col = \"black\", size = size, fontface = \"bold\") +\n    geom_node_text(ggplot2::aes(label = xpos), nudge_y = -0.35, size = size) +\n    theme_graph(base_family = \"Arial Narrow\")\n}\n```\n\nAnd plot the annotation:\n\n```{r}\n#| fig-width: 7\n#| fig-height: 3\n#| fig-cap: \"Dependency structure of a sample parsed sentence.\"\n\nplot_annotation(annotation, size = 2.5)\n```\n\n## Annotate a corpus\n\nParsing text is a computationally intensive process and can take time. So for the purposes of this lab, we'll create a smaller sub-sample of the the data. By adding a column called **text_type** which includes information extracted from the file names, we can sample 5 texts from each.\n\n```{r}\n#| message: false\n#| warning: false\n#| error: false\n\nset.seed(123)\nsub_corpus <- quanteda.extras::sample_corpus %>%\n  mutate(text_type = str_extract(doc_id, \"^[a-z]+\")) %>%\n  group_by(text_type) %>%\n  sample_n(5) %>%\n  ungroup() %>%\n  dplyr::select(doc_id, text)\n```\n\n### Parallel processing\n\nParallel processing is a method whereby separate parts of an overall complex task are broken up and run simultaneously on multiple CPUs, thereby reducing the amount of time for processing. Part-of-speech tagging and dependency parsing are computationally intensive, so using parallel processing can save valuable time.\n\nThe **udpipe()** function has an argument for assigning cores: **parallel.cores = 1L**. It's easy to set up, so feel free to use that option.\n\nA second option, requires more preparation, but is even faster. So we'll walk through how it works. First, we will split the corpus based on available cores.\n\n```{r}\ncorpus_split <- split(sub_corpus, seq(1, nrow(sub_corpus), by = 10))\n```\n\nFor parallel processing in R, we'll us the package **future.apply**.\n\n```{r}\n#| message: false\n#| warning: false\n#| error: false\n\nlibrary(future.apply)\n```\n\nNext, we set up our parallel session by specifying the number of cores, and creating a simple annotation function.\n\n```{r anno_function}\nncores <- 4L\nplan(multisession, workers = ncores)\n\nannotate_splits <- function(corpus_text) {\n  ud_model <- udpipe_load_model(\"../models/english-ewt-ud-2.5-191206.udpipe\")\n  x <- data.table::as.data.table(udpipe_annotate(ud_model, x = corpus_text$text,\n                                                 doc_id = corpus_text$doc_id))\n  return(x)\n}\n```\n\nFinally, we annotate using **future_lapply**. On my machine, this takes roughly 32 seconds.\n\n```{r anno_splits}\nannotation <- future_lapply(corpus_split, annotate_splits, future.seed = T)\n```\n\nAs you might guess, the output is a list of data frames, so we'll combine them using **rbindlist()**.\n\n```{r}\nannotation <- data.table::rbindlist(annotation)\n```\n\n## Process with quanteda\n\n### Format the data for quanteda\n\nIf we want to do any further processing in **quanteda**, we need to make a couple of adjustments to our data frame. \n\n```{r}\nanno_edit <- annotation %>%\n  dplyr::select(doc_id, sentence_id, token_id, token, lemma, upos, xpos, head_token_id, dep_rel) %>%\n  rename(pos = upos, tag = xpos)\n\nanno_edit <- structure(anno_edit, class = c(\"spacyr_parsed\", \"data.frame\"))\n```\n\n### Convert to tokens\n\n```{r}\nsub_tkns <- as.tokens(anno_edit, include_pos = \"tag\", concatenator = \"_\")\n```\n\n### Create a dfm\n\nWe will also extract and assign the variable **text_type** to the tokens object.\n\n```{r}\ndoc_categories <- names(sub_tkns) %>%\n  data.frame(text_type = .) %>%\n  mutate(text_type = str_extract(text_type, \"^[a-z]+\"))\n\ndocvars(sub_tkns) <- doc_categories\n\nsub_dfm <- dfm(sub_tkns)\n```\n\nAnd check the frequencies:\n\n```{r}\n#| code-fold: true\n\ntextstat_frequency(sub_dfm, n = 10) |>\n  gt()\n```\n\n### Filter/select tokens\n\nThere are multiple ways to filter/select the tokens we want to count. We could, for example, just filter out all rows in the annotation data frame tagged as **PUNCT**, if we wanted to exclude punctuation from our counts.\n\nI would, however, advise against altering the original parsed file. We may want to try different options, and we want to avoid having to re-parse our corpus, as that is the most computationally intensive step in the processing pipeline. In fact, if this were part of an actual project, I would advise that you save the parsed data frame as a **.csv** file using **write_csv()** for later use.\n\nSo we will try an alternative. We use the **tokens_select()** function to either keep or remove tokens based on regular expressions.\n\n```{r}\nsub_dfm <- sub_tkns %>%\n  tokens_select(\"^.*[a-zA-Z0-9]+.*_[a-z]\", selection = \"keep\", valuetype = \"regex\", case_insensitive = T) %>%\n  dfm()\n\n```\n\nAnd check the frequencies:\n\n```{r}\n#| code-fold: true\n#| tbl-cap: \"Most frequent tokens tagged for part-of-speech in sub-sample of the corpus.\"\n\ntextstat_frequency(sub_dfm, n = 10) |>\n  gt() |>\n  as_raw_html()\n```\n\n\nIf we want to compare one text-type (as our target corpus) to another (as our reference corpus), we can easily subset the data.\n\n```{r subset_corpus}\nacad_dfm <- dfm_subset(sub_dfm, text_type == \"acad\") %>% dfm_trim(min_termfreq = 1)\nfic_dfm <- dfm_subset(sub_dfm, text_type == \"fic\") %>% dfm_trim(min_termfreq = 1)\n```\n\nAnd finally, we can generate a keyness table, \n\n```{r}\nacad_v_fic <- keyness_table(acad_dfm, fic_dfm) %>%\n  separate(col = Token, into = c(\"Token\", \"Tag\"), sep = \"_\")\n```\n\nFrom that data, we can filter specific lexical classes, like modal verbs:\n\n```{r}\n#| code-fold: true\n#| tbl-cap: \"A keyness comparision of modal verbs in a sub-sample of the academic vs. fiction text-types.\"\n\nacad_v_fic %>% filter(Tag == \"md\") |>\n  gt() |>\n  fmt_number(columns = c('LL', 'LR', 'Per_10.4_Tar', 'Per_10.4_Ref'), decimals = 2) |>\n  fmt_number(columns = c('DP_Tar', 'DP_Ref'), decimals = 3) |>\n  fmt_number(columns = c('PV'), decimals = 5) |>\n  as_raw_html()\n```\n\n___\n\\begin{center}\nSTOP!\\\\\nCOMPLETE TASK 1\n\\end{center} \n___\n\n### Extract phrases\n\nWe can also extract phrases of specific types. To so so, we first use the function **as_phrasemachine()** to add a new column to our annotation called **phrase_tag**.\n\n```{r}\nannotation$phrase_tag <- as_phrasemachine(annotation$upos, type = \"upos\")\n```\n\nNext, we can use the function **keywords_phrases()** to extract phrase-types based on regular expressions. Refer to the documentation for suggested **regex** patterns: <https://www.rdocumentation.org/packages/udpipe/versions/0.8.6/topics/keywords_phrases>.\n\nYou can also read examples of use cases: <https://bnosac.github.io/udpipe/docs/doc7.html>.\n\nFirst, we'll subset our data into annotations by text-type. \n\n```{r anno_split}\nacad_anno <- annotation %>% filter(str_detect(doc_id, \"acad\"))\nfic_anno <- annotation %>% filter(str_detect(doc_id, \"fic\"))\n```\n\n\n```{r key_phrases}\n\nacad_nps <- keywords_phrases(x = acad_anno$phrase_tag, term = tolower(acad_anno$token), \n                          pattern = \"(A|N)*N(P+D*(A|N)*N)*\", \n                          is_regex = TRUE, detailed = T)\n\n\nfic_nps <- keywords_phrases(x = fic_anno$phrase_tag, term = tolower(fic_anno$token), \n                             pattern = \"(A|N)*N(P+D*(A|N)*N)*\", \n                             is_regex = TRUE, detailed = T)\n```\n\n\n```{r}\n#| code-fold: true\n#| tbl-cap: \"Noun phrases extracted from a sub-sample of the corpus.\"\n\nacad_nps |>\n  head(25) |>\n  gt() |>\n  as_raw_html()\n```\n\nNote that although the function uses the term **keywords**, it is **NOT** executing a hypothesis test of any kind.\n\n### Extract only unique phrases\n\nNote that **udpipe** extracts overlapping constituents of phrase structures. Normally, we would want only *unique* phrases. To find those we'll take advantage of the **start** and **end** indexes, using the **between()** function from the **data.table** package.\n\nThat will generate a logical vector, which we can use to filter out only those phrases that don't overlap with another.\n\n```{r acad_unique}\n\nidx <- seq(1:nrow(acad_nps))\n\nis_unique <- lapply(idx, function(i) sum(data.table::between(acad_nps$start[i], acad_nps$start, acad_nps$end) & data.table::between(acad_nps$end[i], acad_nps$start, acad_nps$end)) == 1) %>% unlist()\n\nacad_nps <- acad_nps[is_unique, ]\n```\n\n```{r fic_unique}\nidx <- seq(1:nrow(fic_nps))\n\nis_unique <- lapply(idx, function(i) sum(data.table::between(fic_nps$start[i], fic_nps$start, fic_nps$end) & data.table::between(fic_nps$end[i], fic_nps$start, fic_nps$end)) == 1) %>% unlist()\n\nfic_nps <- fic_nps[is_unique, ]\n```\n\nWe can also add a rough accounting of the lengths of the noun phrases by summing the spaces and adding 1.\n\n```{r}\nacad_nps <- acad_nps %>%\n  mutate(phrase_length = str_count(keyword, \" \") + 1)\n\nfic_nps <- fic_nps %>%\n  mutate(phrase_length = str_count(keyword, \" \") + 1)\n```\n\n\n```{r}\n#| code-fold: true\n#| tbl-cap: \"Unique noun phrases extracted from a sub-sample of the corpus.\"\n\nfic_nps |>\n  head(10) |>\n  gt() |>\n  as_raw_html()\n```\n\n::: callout-important\n## Pause for Lab Set Question\n\nComplete [Task 2 in Lab Set 2](../lab_sets/LabSet_02.qmd#distributions).\n:::\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"feature-engineering.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","editor":"source"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":[]}
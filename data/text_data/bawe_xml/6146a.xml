<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd">
<TEI.2 id="_6146a" n="version 1.0">
<teiHeader>
<fileDesc>
<titleStmt>
<title>Design of an anemometer, with scan, on an FPGA</title>
</titleStmt>
<extent/>
<publicationStmt>
<distributor>British Academic Written English (BAWE) corpus</distributor>
<availability>
<p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p>
<p>1. The corpus files are not distributed in either their original form or in modified form.</p>
<p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p>
<p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p>
<p>4. The BAWE corpus developers (contact: BAWE@warwick.ac.uk) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p>
<p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p>
</availability>
</publicationStmt>
<notesStmt>
<note resp="British Academic Written English (BAWE) corpus project">Page footer contains: student name; page number; date. </note>
<note resp="British Academic Written English (BAWE) corpus project">Appendix content: 8. AppendicesAppendix A - Derivation of BCD counter logicAppendix B - Schematic DiagramsAppendix C - 7 Segment Driver VHDL ListingAppendix D - Pinout TableAppendix E - Truth tables for test pattern derivation</note>
</notesStmt>
<sourceDesc>
<p n="level">2</p>
<p n="date">2005-04</p>
<p n="module title">Digital Circuit Design</p>
<p n="module code">EE2Q2</p>
<p n="genre family">Design specification</p>
<p n="discipline">Cybernetics &amp; Electronic Engineering</p>
<p n="disciplinary group">PS</p>
<p n="grade">D</p>
<p n="number of authors">1</p>
<p n="number of words">4114</p>
<p n="number of s-units">229</p>
<p n="number of p">114</p>
<p n="number of tables">3</p>
<p n="number of figures">8</p>
<p n="number of block quotes">0</p>
<p n="number of formulae">16</p>
<p n="number of lists">9</p>
<p n="number of paragraphs formatted like lists">3</p>
<p n="abstract present">abstract present</p>
<p n="average words per s-unit">18.0</p>
<p n="average s-units per p">2.0</p>
<p n="macrotype of assignment">simple assignment</p>
</sourceDesc>
</fileDesc>
<encodingDesc>
<p>TEI P4 (documented in: BAWE.documentation.pdf)</p>
</encodingDesc>
<profileDesc>
<particDesc>
<person>
<p n="gender">m</p>
<p n="year of birth">1985</p>
<p n="first language">English</p>
<p n="education">UKa</p>
<p n="course">Electronic Engineering</p>
<p n="student ID">6146</p>
</person>
</particDesc>
</profileDesc>
</teiHeader>
<text>
<front>
<titlePage>
<docTitle>
<titlePart rend="bold">Design of an anemometer, with scan, on an FPGA</titlePart>
</docTitle>
<titlePart>by <name type="student name"/>
</titlePart>
</titlePage>
</front>
<body>
<div1 type="abstract">
<head rend="bold">Summary</head>
<p n="p1.114">
<s n="s1.5;p1.114">This report details the design and implementation of an anemometer on an FPGA, using Xilinx ISE software. </s>
<s n="s2.5;p1.114">The task was split up into 6 main components, though the design was focused around including the ability to test, through scan. </s>
<s n="s3.5;p1.114">Most design was carried out in schematic form, with one part written in VHDL code. </s>
<s n="s4.5;p1.114">The report includes schematic diagrams for every part of the solution, along with simulation results, and documents any problems encountered, along with their solutions. </s>
<s n="s5.5;p1.114">Also, the necessary scan test patterns have been worked out and included. </s>
</p>
</div1>
<div1 type="front-back-matter">
<head rend="bold">Contents</head>
<p/>
</div1>
<div1 type="front-back-matter">
<head rend="bold">1. Glossary</head>
<list type="simple">
<item>Anemometer - measures wind speed</item>
<item>FPGA - Field Programmable Gate Array</item>
<item>HDL - Hardware Description Language</item>
<item>VHDL - VHSIC (Very High Speed Integrated Circuit) HDL</item>
<item>BCD counter - Binary Coded Decimal counter</item>
<item>Bus - A collection of wires through which data is transmitted.</item>
<item>MSB - Most Significant Bit</item>
<item>LSB - Least Significant Bit</item>
<item>SOC - System On a Chip</item>
</list>
<p/>
</div1>
<div1 type="section">
<head rend="bold">2. Introduction</head>
<div2>
<head rend="bold italic">2.1. The Project</head>
<p n="p2.114">
<s n="s1.2;p2.114">The main objective of this project was to produce a logic circuit to complement a mechanical anemometer head. </s>
<s n="s2.2;p2.114">The logic must perform the following: </s>
</p>
<list type="ordered">
<item>Receive a frequency of pulses between 0 and 99Hz from the anemometer head.</item>
<item>Calculate the average frequency over 10 second periods</item>
<item>Output this value to the 7 segment display</item>
<item>Update the 7 segment display at the end of each 10 second period</item>
</list>
<p n="p3.114">
<s n="s1.1;p3.114">The solution was implemented using: </s>
</p>
<list type="bulleted">
<item>Xilinx XC2S300E FPGA (from the Spartan 2E series)</item>
<item>Digilent, Inc D2-FT System Board</item>
<item>Digilent, Inc DIO4 Peripheral Board</item>
<item>A Range of Xilinx ISE CAD software tools</item>
<item>ModelSim from Model Technologyâ„¢</item>
</list>
</div2>
<div2>
<head rend="bold italic">2.2. Background Information</head>
<div3>
<head rend="bold">2.2.1. FPGA Design</head>
<p n="p4.114">
<s n="s1.2;p4.114">Implementing a design using an FPGA is a combined hardware and software solution. </s>
<s n="s2.2;p4.114">This has a big advantage over a purely hardware solution. </s>
</p>
<p n="p5.114">
<s n="s1.3;p5.114">An FPGA can be programmed and reprogrammed freely without removing it from its application, making it ideal for developing a new design. </s>
<s n="s2.3;p5.114">Partial and incomplete designs can be tested by programming them onto the FPGA, unlike in hardware design, where designs can only be simulated. </s>
<s n="s3.3;p5.114">There can often be significant differences between computer simulation results, and the performance of a design once manufactured. </s>
</p>
<p n="p6.114">
<s n="s1.2;p6.114">FPGAs are typically programmed using HDLs, although in this project nearly all the design was done by creating logic circuit schematics. </s>
<s n="s2.2;p6.114">The Xilinx software can then 'synthesise' the designs into VHDL. </s>
</p>
<p n="p7.114">
<s n="s1.1;p7.114">The DIO4 provides, amongst other features: </s>
</p>
<list type="bulleted">
<item>4-digit seven segment LED display;</item>
<item>8 individual LEDs;</item>
<item>4 pushbuttons;</item>
<item>8 slide switches; [1]</item>
</list>
<p n="p8.114">
<s n="s1.1;p8.114">The D2-FT provides, amongst other features: </s>
</p>
<list type="bulleted">
<item>An SMD 50MHz oscillator, and a socket for a second oscillator;</item>
<item>A JTAG programming port; [2]</item>
</list>
</div3>
<div3>
<head rend="bold">2.2.2. Design for Test</head>
<p n="p9.114">
<s n="s1.5;p9.114">Testing a logic circuit once it has been implemented is not as simple as it once was. </s>
<s n="s2.5;p9.114">Modern ICs frequently contain millions of logic gates which means that exhaustive testing of a chip is impossible. </s>
<s n="s3.5;p9.114">However, manufacturers still need to guarantee the functionality of their products. </s>
<s n="s4.5;p9.114">There are methods of testing circuitry that enable manufacturers to do this, but they require some extra logic to be included in the design. </s>
<s n="s5.5;p9.114">Therefore, the complexity of present circuits and the advent of SOCs makes it mandatory to start considering testing early in the design process [3]. </s>
</p>
<p n="p10.114">
<s n="s1.4;p10.114">One such method of testing is Scan. </s>
<s n="s2.4;p10.114">The basic idea is to connect all of the flip-flops in a circuit into a serial chain (shift register) giving the ability to scan data in or out. </s>
<s n="s3.4;p10.114">Multiplexers are included, to select whether the circuit is configured for normal operation, or as a scan chain. </s>
<s n="s4.4;p10.114">The circuit in figure 2.2.1 would be tested as follows: </s>
</p>
<p rend="ordered" n="p11.114">
<s n="s1.1;p11.114">Pass values into 'scan in', and using the scan chain, set the initial values of flip-flops. </s>
</p>
<p rend="ordered" n="p12.114">
<s n="s1.1;p12.114">In normal operation mode, pass the values through the combinational logic. </s>
</p>
<p rend="ordered" n="p13.114">
<s n="s1.1;p13.114">Use the scan chain to clock the outputs through to 'scan out', where they can be checked against theoretical outputs. </s>
</p>
<p n="p14.114">
<s n="s1.2;p14.114">This process requires pre-determined test patterns to be used as the initial flip-flop values. </s>
<s n="s2.2;p14.114">These patterns are specially calculated to highlight any possible faults. </s>
</p>
<figure id="BAWE_6146a-fig.001">
<head>Figure 2.2.1 - Scan principles applied to a basic sequential logic circuit [4] Source [4] is recommended as a brief introduction to Scan.</head>
</figure>
<p n="p15.114">
<s n="s1.2;p15.114">The circuits in this project also include a 'scanClock' and 'clockSelect' pin, which means the clocking through of values can be done at a controlled speed, or with a push button, since no dedicated test hardware is available. </s>
<s n="s2.2;p15.114">This technique is also necessary to convert asynchronous circuits, such as the divider in 3.3, into a synchronous form that can be used as a shift register. </s>
</p>
</div3>
</div2>
</div1>
<div1 type="section">
<head rend="bold">3. Procedure</head>
<div2>
<head rend="bold italic">3.1. Overall Task</head>
<p n="p16.114">
<s n="s1.1;p16.114">The main design problem has been tackled by splitting it into a number of relatively simple parts: </s>
</p>
<figure id="BAWE_6146a-fig.002">
<head>Figure 3.1 - breakdown of the design problem into separate components [5]</head>
</figure>
<p n="p17.114">
<s n="s1.2;p17.114">The anemometer head had been previously constructed from aluminium. </s>
<s n="s2.2;p17.114">Its design and construction is not documented in this report. </s>
</p>
</div2>
<div2>
<head rend="bold italic">3.2. BCD Counter</head>
<p n="p18.114">
<s n="s1.5;p18.114">The BCD counter forms the basis for the entire circuit. </s>
<s n="s2.5;p18.114">Its job is to count the input pulses from the anemometer head over 10 second periods. </s>
<s n="s3.5;p18.114">After 10 seconds, it receives a reset signal from the timing generator. </s>
<s n="s4.5;p18.114">It was designed first, as several other components in this project can be easily adapted from the schematic of a BCD counter. </s>
<s n="s5.5;p18.114">In terms of the logic, it is the most complex component to design. </s>
</p>
<p n="p19.114">
<s n="s1.3;p19.114">The counter needs to be modulo-10, which is not a power of two, so a synchronous setup was used, with D-type flip-flops to simplify design. </s>
<s n="s2.3;p19.114">4 flip-flops (A, B, C, D) were required, since log <hi rend="sub">2</hi>10 = 3.3. </s>
<s n="s3.3;p19.114">The flip-flops needed to go through the following states: </s>
</p>
<table id="BAWE_6146a-tab.001">
<row>
<cell/>
</row>
</table>
<p n="p20.114">
<s n="s1.1;p20.114">In order to achieve these states in a synchronous counter, the flip flops must be set up with the following logic before their D input (the full derivation using K-maps is given in Appendix A): </s>
</p>
<p n="p21.114">
<s n="s1.1;p21.114">
<formula notation="" id="BAWE_6146a-form.001"/> </s>
</p>
<p n="p22.114">
<s n="s1.1;p22.114">
<formula notation="" id="BAWE_6146a-form.002"/> </s>
</p>
<p n="p23.114">
<s n="s1.1;p23.114">
<formula notation="" id="BAWE_6146a-form.003"/> </s>
</p>
<p n="p24.114">
<s n="s1.1;p24.114">
<formula notation="" id="BAWE_6146a-form.004"/> </s>
</p>
<p n="p25.114">
<s n="s1.2;p25.114">The fact that D-flip-flops were used means no control over the initial state of the flip-flops is given. </s>
<s n="s2.2;p25.114">Therefore, it is important to check the unwanted states: </s>
</p>
<p n="p26.114">
<s n="s1.1;p26.114">
<formula notation="" id="BAWE_6146a-form.005"/> </s>
</p>
<p n="p27.114">
<s n="s1.1;p27.114">
<formula notation="" id="BAWE_6146a-form.006"/> </s>
</p>
<p n="p28.114">
<s n="s1.1;p28.114">
<formula notation="" id="BAWE_6146a-form.007"/> </s>
</p>
<p n="p29.114">
<s n="s1.1;p29.114">
<formula notation="" id="BAWE_6146a-form.008"/> </s>
</p>
<p n="p30.114">
<s n="s1.1;p30.114">
<formula notation="" id="BAWE_6146a-form.009"/> </s>
</p>
<p n="p31.114">
<s n="s1.2;p31.114">Several of the unwanted states are followed by another unwanted state. </s>
<s n="s2.2;p31.114">However, they all lead to acceptable states within 3 (max) state changes, so no revision of the logic is necessary. </s>
</p>
<p n="p32.114">
<s n="s1.1;p32.114">The logic expressions were constructed with gates in a schematic diagram using Xilinx ECS. The diagram is show in figure B.1 of Appendix B. While this counter did count through 10 states in natural binary, there were several modifications required before the BCD counter would exactly suit this project. </s>
</p>
<p n="p33.114">
<s n="s1.2;p33.114">Firstly, the simple flip-flops were replaced by ones with a 'clear' input. </s>
<s n="s2.2;p33.114">This allows the counter to be reset at the end of each 10 second period. </s>
</p>
<p n="p34.114">
<s n="s1.1;p34.114">Secondly, since an essential part of this project is the ability to test the logic after implementation, the schematic was revised, to include: </s>
</p>
<list type="bulleted">
<item>scanEnable (input pin)</item>
<item>scanIn (input pin)</item>
<item>scanOut (output pin)</item>
<item>clockSelect (input pin)</item>
<item>scanClock (input pin)</item>
</list>
<p n="p35.114">
<s n="s1.1;p35.114">An explanation of Scan is given in section 2.2.2. </s>
</p>
<p n="p36.114">
<s n="s1.2;p36.114">Also a multiplexer was included on the 'clear' input. </s>
<s n="s2.2;p36.114">Otherwise, the scan chain could be interrupted if the clear input became HIGH. </s>
</p>
<p n="p37.114">
<s n="s1.2;p37.114">Note: there is no included ability to test the multiplexers involved in the scan process. </s>
<s n="s2.2;p37.114">These are assumed to be fault free. </s>
</p>
<p n="p38.114">
<s n="s1.1;p38.114">The final schematic for the BCD counter is figure B.2 of Appendix B. </s>
</p>
<p n="p39.114">
<s n="s1.2;p39.114">Using Xilinx Project Navigator, the schematic was then synthesised, to create a VHDL (.vhf/.vhd) file, which was simulated in ModelSim. </s>
<s n="s2.2;p39.114">For simulation results, see section 4.2. </s>
</p>
</div2>
<div2>
<head rend="bold italic">3.3. Clock</head>
<p n="p40.114">
<s n="s1.1;p40.114">The purpose of the clock is to supply a regular 0.8Hz square wave to the timing generator, so that the appropriate timing signal can be created. </s>
</p>
<p n="p41.114">
<s n="s1.4;p41.114">The oscillator provided on the D2-FT runs at 50Mhz. </s>
<s n="s2.4;p41.114">A 0.8Hz clock (as required) can be produced by scaling down this fast clock with a prescaler. </s>
<s n="s3.4;p41.114">The simplest type of prescaler would be asynchronous, with successive 'divide by 2' stages. </s>
<s n="s4.4;p41.114">The number of stages required is given by: </s>
</p>
<p n="p42.114">
<s n="s1.1;p42.114">
<formula notation="" id="BAWE_6146a-form.010"/> </s>
</p>
<p n="p43.114">
<s n="s1.2;p43.114">Therefore 26 flip-flops were used in this prescaler. </s>
<s n="s2.2;p43.114">The schematic for this prescaler has been named "div26", to avoid confusion with the prescaler which scales the input from the anemometer head. </s>
</p>
<p n="p44.114">
<s n="s1.2;p44.114">Rounding up to 26 flip-flops resulted in an imprecise frequency for the clock. </s>
<s n="s2.2;p44.114">However, a clock running at <formula notation="" id="BAWE_6146a-form.011"/> Hz is accurate enough for the specification of this project. </s>
</p>
<p n="p45.114">
<s n="s1.5;p45.114">Drawing out a schematic with 26 flip-flops would be time consuming (and thus error prone), and difficult to fit on a sheet. </s>
<s n="s2.5;p45.114">Also, a design which divides by 67k is very difficult to simulate, since it would take 67 thousand clock cycles to see one cycle of the output. </s>
<s n="s3.5;p45.114">This simulation would take hours. </s>
<s n="s4.5;p45.114">Instead, the 26 stages were broken down into 5 occurrences of a block with 5 stages, and one extra stage. </s>
<s n="s5.5;p45.114">For schematics, see figures B.3 &amp; B.4 of Appendix B. </s>
</p>
<p n="p46.114">
<s n="s1.2;p46.114">The 'divide by 2 <hi rend="sup">5</hi>' block (named 'DIVIDER') was simulated, and shown to work correctly. </s>
<s n="s2.2;p46.114">See section 4.3. </s>
</p>
</div2>
<div2>
<head rend="bold italic">3.4. 7 Segment Display</head>
<div3>
<head rend="bold">3.4.1. Driver</head>
<p n="p47.114">
<s n="s1.5;p47.114">The driver for the display will take a 4-bit natural binary input, and convert it to an 8-bit output. </s>
<s n="s2.5;p47.114">This would be quite a task to design in logic. </s>
<s n="s3.5;p47.114">Instead, the same effect can be produced with around 30 lines of VHDL code. </s>
<s n="s4.5;p47.114">The code used is given in Appendix C (copyright Dr. S. L. </s>
<s n="s5.5;p47.114">Linfoot). </s>
</p>
<p n="p48.114">
<s n="s1.1;p48.114">Using the Project Navigator, a schematic symbol was created from the VHDL code, and then the 7 segment driver could be placed in a schematic drawing like any other component. </s>
</p>
<p n="p49.114">
<s n="s1.3;p49.114">The input and output to the driver are both buses. </s>
<s n="s2.3;p49.114">Using bus taps, these buses were split into wires carrying separate signals. </s>
<s n="s3.3;p49.114">These wires must be named according to the name of the bus, for them to function correctly. </s>
</p>
<figure id="BAWE_6146a-fig.003">
<head>Figure 3.4.1 - 7 segment display driver block placed into a schematic</head>
</figure>
<p n="p50.114">
<s n="s1.2;p50.114">The 7 segment drivers could not be simulated; rather they were tested by connection to a BCD counter, and programmed to the FPGA. This is an example of where the programmability of an FPGA is useful (see 2.2.1). </s>
<s n="s2.2;p50.114">The schematic in figure B.5 (Appendix B) shows the test configuration. </s>
</p>
</div3>
<div3>
<head rend="bold">3.4.2. Separate Digits</head>
<p n="p51.114">
<s n="s1.3;p51.114">There are four digits to the display, each with an anode. </s>
<s n="s2.3;p51.114">If an anode is pulled LOW, the 7 segment driver illuminates segments on the corresponding digit. </s>
<s n="s3.3;p51.114">In order to show a number with multiple digits, the digits must be refreshed alternately, every 1ms and 16ms [1]. </s>
</p>
<p n="p52.114">
<s n="s1.1;p52.114">This must be done using the 50MHz clock on the D2-FT board, which will need to be scaled down by a factor between the following: </s>
</p>
<p n="p53.114">
<s n="s1.1;p53.114">
<formula notation="" id="BAWE_6146a-form.012"/> </s>
</p>
<p n="p54.114">
<s n="s1.1;p54.114">
<formula notation="" id="BAWE_6146a-form.013"/> </s>
</p>
<p n="p55.114">
<s n="s1.1;p55.114">Using multiple asynchronous stages of 'divide by 2', with each stage using one flip-flop, the number of flip-flops required is between: </s>
</p>
<p n="p56.114">
<s n="s1.1;p56.114">
<formula notation="" id="BAWE_6146a-form.014"/> </s>
</p>
<p n="p57.114">
<s n="s1.1;p57.114">
<formula notation="" id="BAWE_6146a-form.015"/> </s>
</p>
<p n="p58.114">
<s n="s1.4;p58.114">Rather than creating another block to scale down the 50MHz clock, an extra output was tapped from the 'div26' block, which is responsible for providing the 0.8Hz clock (section 3.3). </s>
<s n="s2.4;p58.114">However, the way this block was constructed means that a clock can only be tapped off after either 15 or 20 'divide by 2' stages, but no number in between. </s>
<s n="s3.4;p58.114">Opting for output after 20 stages, a new pin named 'div20' was added to the 'div26' schematic. </s>
<s n="s4.4;p58.114">Figure B.4, Appendix B. </s>
</p>
<p n="p59.114">
<s n="s1.1;p59.114">This project requires only the 2 right-most digits of the display (digits 3 &amp; 4), therefore digits 1 &amp; 2 were disabled by connecting their anodes to Vcc. </s>
</p>
<figure id="BAWE_6146a-fig.004">
<head>Figure 3.4.2 - connections to the LED display anodes</head>
</figure>
</div3>
</div2>
<div2>
<head rend="bold italic">3.5. Timing Generator</head>
<p n="p60.114">
<s n="s1.3;p60.114">The timing generator is responsible for producing two timing waveforms. </s>
<s n="s2.3;p60.114">The first of these supplies the clock input to the latch, the second goes to the clear input of the BCD counter. </s>
<s n="s3.3;p60.114">The two timing signals should look as follows: </s>
</p>
<figure id="BAWE_6146a-fig.005">
<head>Figure 3.5.1 - Timing waveform to the latch [5]</head>
</figure>
<p n="p61.114">
<s n="s1.1;p61.114">
<formula notation="" id="BAWE_6146a-form.016"/> </s>
</p>
<figure id="BAWE_6146a-fig.006">
<head>Figure 3.5.2 - Timing waveform to the BCD counter</head>
</figure>
<p n="p62.114">
<s n="s1.2;p62.114">The latter signal has a 0 to 1 transition one clock cycle after the former. </s>
<s n="s2.2;p62.114">This means that the latch will store the value from the counter, and <hi rend="italic">then</hi> the counter is reset. </s>
</p>
<p n="p63.114">
<s n="s1.2;p63.114">Coincidentally, the timing waveform in figure 1 is identical to the MSB of the BCD counter (see figure 4.2.1 for counter simulation results). </s>
<s n="s2.2;p63.114">Therefore, the same logic circuit was used. </s>
</p>
<p n="p64.114">
<s n="s1.1;p64.114">The timing waveform in figure 2 was produced as the AND of the MSB and LSB of a BCD counter: </s>
</p>
<table id="BAWE_6146a-tab.002">
<row>
<cell/>
</row>
</table>
<p n="p65.114">
<s n="s1.1;p65.114">Output pins to the two unused bits (B and C) were removed, leaving the schematic shown in figure B.6 (Appendix B) </s>
</p>
</div2>
<div2>
<head rend="bold italic">3.6. Prescaler</head>
<p n="p66.114">
<s n="s1.3;p66.114">The task of the prescaler is to divide the input frequency by 10. </s>
<s n="s2.3;p66.114">This is necessary because the BCD counter counts pulses for 10 seconds. </s>
<s n="s3.3;p66.114">When the two components are combined, the output of the counter is the average frequency over the 10 second period. </s>
</p>
<p n="p67.114">
<s n="s1.4;p67.114">The prescaler, like the timing generator, is very similar to the BCD counter. </s>
<s n="s2.4;p67.114">The MSB has one 0 to 1 transition for every ten of the original clock, thus it is an effective 'divide by 10' circuit. </s>
<s n="s3.4;p67.114">However, the first 0 to 1 transition occurs after only 8 clock cycles, rather than 10. </s>
<s n="s4.4;p67.114">This can be corrected by inverting the output, giving the schematic shown in figure B.7, Appendix B. When simulated, the circuit gives the output as shown in section 4.6. </s>
</p>
</div2>
<div2>
<head rend="bold italic">3.7. Latch</head>
<p n="p68.114">
<s n="s1.6;p68.114">The latch has two purposes. </s>
<s n="s2.6;p68.114">Firstly it holds (latches) the value that is being shown on the display, while the BCD counter resets and counts the next value. </s>
<s n="s3.6;p68.114">Secondly, it takes two 4-bit input signals, and outputs one 4-bit signal to the 7 segment display driver. </s>
<s n="s4.6;p68.114">This output signal switches between the two stored 4-bit values at the same rate as the display is switching between digits. </s>
<s n="s5.6;p68.114">This ultimately gives the appearance that information is being passed to both digits simultaneously. </s>
<s n="s6.6;p68.114">To ensure synchronicity of these two switching actions, the latch uses the same clock input that is responsible for pulling display anodes high and low (see section 3.4.2). </s>
</p>
<p n="p69.114">
<s n="s1.5;p69.114">The latch was created in a very simple way, using a single D-type flip-flop for each input bit. </s>
<s n="s2.5;p69.114">The flip-flop lets a value through to its output every time a 0 to 1 transition is detected on its clock input. </s>
<s n="s3.5;p69.114">This clock input is received from the timing generator (section 3.5). </s>
<s n="s4.5;p69.114">The switching between stored values was carried out using a multiplexer on each of the 4 output bits. </s>
<s n="s5.5;p69.114">See figure B.8 (Appendix B) for the schematic diagram, and figure 4.7 for simulation results. </s>
</p>
</div2>
<div2>
<head rend="bold italic">3.8. Combining the Components</head>
<p n="p70.114">
<s n="s1.2;p70.114">Each component produced so far was placed inside a hierarchical block. </s>
<s n="s2.2;p70.114">The blocks were then combined in the configuration in figure 3.1.1, giving the schematic shown in figure B.9 (Appendix B). </s>
</p>
<p n="p71.114">
<s n="s1.6;p71.114">Since the anemometer should be capable of showing readings between 0 and 99, 2 BCD counter blocks were used, one for each digit. </s>
<s n="s2.6;p71.114">These supply the 8 input bits to the latch. </s>
<s n="s3.6;p71.114">The counter responsible for the 'units' digit, simply takes its input from the prescaler, as shown in figure 3.1.1. </s>
<s n="s4.6;p71.114">However the second counter must have its input divided by 10 first, so that it can supply the 'tens' digit. </s>
<s n="s5.6;p71.114">This input was produced by inverting the MSB from the 'units' counter. </s>
<s n="s6.6;p71.114">It has previously been shown that the MSB of a BCD counter effectively divides the input by 10, but that it must be inverted to have a 0 to 1 transition at the correct position (see figure 4.2.1 for BCD counter output waveform, and figure 4.6.1 for the waveform given by the MSB once it is inverted). </s>
</p>
<p n="p72.114">
<s n="s1.1;p72.114">The scan chain was linked up in the following order: </s>
</p>
<figure id="BAWE_6146a-fig.007"/>
<p n="p73.114">
<s n="s1.1;p73.114">The scan chain contained 50 flip-flops altogether. </s>
</p>
<p n="p74.114">
<s n="s1.1;p74.114">All the inputs and outputs from the circuit must be assigned to the appropriate output pins of the FPGA. A pin-out table is included in Appendix D, showing which FPGA pins are connected to which peripherals on the 2 circuit boards. </s>
</p>
<p n="p75.114">
<s n="s1.4;p75.114">Scan out was connected to an LED, so that outputs can be seen. </s>
<s n="s2.4;p75.114">This meant that the output pin J3 (LEDG) must also be assigned. </s>
<s n="s3.4;p75.114">For any LEDs on the DIO4 board to be active, the pin J3 must be pulled high. </s>
<s n="s4.4;p75.114">In the schematic figure B.9, an output pin labelled 'LEDG' can be seen to be connected to Vcc for this purpose. </s>
</p>
<p n="p76.114">
<s n="s1.3;p76.114">The input buffer (IBUF) for the clock input was changed to a 'global clock input buffer' (IBUFG). </s>
<s n="s2.3;p76.114">This is necessary for the circuit to use the fast 50Mhz clock provided by the system board. </s>
<s n="s3.3;p76.114">An IBUFG was also used on the input for the pulses from the anemometer head. </s>
</p>
<p n="p77.114">
<s n="s1.3;p77.114">At this stage, the prototype was ready for testing. </s>
<s n="s2.3;p77.114">Any problems encountered were recorded and corrected. </s>
<s n="s3.3;p77.114">These problems and their solutions are documented in section 6. </s>
</p>
</div2>
</div1>
<div1 type="section">
<head rend="bold">4. Findings</head>
<p n="p78.114">
<s n="s1.1;p78.114">In order to test the normal operation of the circuits in this project, all simulations were carried out with 'scanEnable' and 'clockSelect' at logic zero. </s>
</p>
<div2>
<head rend="bold italic">4.2. BCD Counter</head>
<p n="p79.114">
<s n="s1.1;p79.114">The simulation in figure 4.2.1 shows that the bits a, b, c, d follow a natural binary sequence with 10 states, as desired. </s>
</p>
<figure id="BAWE_6146a-pic.001">
<head>Figure 4.2.1 - BCD counter simulation results</head>
</figure>
</div2>
<div2>
<head rend="bold italic">4.3. Clock</head>
<p n="p80.114">
<s n="s1.2;p80.114">The 'DIVIDER' block has been shown (figure 4.3.1) to produce one output pulse for every 2 <hi rend="sup">5</hi> (32) input pulses, which is the required result. </s>
<s n="s2.2;p80.114">The input and output are labelled 'timein' and 'timeout' respectively. </s>
</p>
<figure id="BAWE_6146a-pic.002">
<head>Figure 4.3.1 - 'DIVIDER' block simulation results</head>
</figure>
</div2>
<div2>
<head rend="bold italic">4.4. 7 Segment Display Drivers</head>
<p n="p81.114">
<s n="s1.3;p81.114">Using the test configuration shown in figure B.5 (Appendix B), all 4 digits of the display were illuminated, at equal brightness, showing the same integer on each. </s>
<s n="s2.3;p81.114">This is the expected result, since all digits were receiving the same signal from the BCD counter. </s>
<s n="s3.3;p81.114">The digits counted through the correct sequence, 0 to 9. </s>
</p>
<p n="p82.114">
<s n="s1.1;p82.114">The display did not appear to be affected by having a refresh time slightly outside the 1ms-16ms recommendation. </s>
</p>
</div2>
<div2>
<head rend="bold italic">4.5. Timing Generator</head>
<p n="p83.114">
<s n="s1.2;p83.114">In figure 4.5.1, the waveform labelled 'timing' is exactly the waveform required. </s>
<s n="s2.2;p83.114">It can be seen to match the requirement shown in figure 3.5.1. </s>
</p>
<figure id="BAWE_6146a-pic.003">
<head>Figure 4.5.1 - Timing generator simulation results.</head>
</figure>
</div2>
<div2>
<head rend="bold italic">4.6. Prescaler</head>
<p n="p84.114">
<s n="s1.3;p84.114">The prescaler simulation results are shown in figure 4.6.1. </s>
<s n="s2.3;p84.114">The waveform labelled 'div10' gives one pulse for every 10 of the input labelled 'clock'. </s>
<s n="s3.3;p84.114">Although the signal 'div10' is not a square wave (does not have a duty of 50%), it meets the requirement. </s>
</p>
<figure id="BAWE_6146a-pic.004">
<head>4.6.1 - Prescaler simulation results.</head>
</figure>
</div2>
<div2>
<head rend="bold italic">4.7. Latch</head>
<p n="p85.114">
<s n="s1.5;p85.114">The latch simulation results are shown in figure 4.7.1. </s>
<s n="s2.5;p85.114">Initially, the 'timing' and 'refresh' inputs were set at 0. </s>
<s n="s3.5;p85.114">This caused the outputs to be zero. </s>
<s n="s4.5;p85.114">At 400Î¼s, 'timing' switches to 1, causing the latch to pass through and hold the values on inputs 'ain', 'bin', 'cin', 'din'. </s>
<s n="s5.5;p85.114">These values are held until 'refresh' also goes to 1 after 700Î¼s, at which time the outputs change to the values of 'tensa', 'tensb', 'tensc', 'tensd'. </s>
</p>
<figure id="BAWE_6146a-pic.005">
<head>Figure 4.7.1 - latch simulation results.</head>
</figure>
</div2>
<div2>
<head rend="bold italic">4.8. Combining the Components</head>
<p n="p86.114">
<s n="s1.1;p86.114">The circuit was ultimately proven to work, and be fault free. </s>
</p>
<p n="p87.114">
<s n="s1.2;p87.114">When a signal generator was used to supply the input pulses, the 7 segment display did show values slightly higher than signal generator was providing. </s>
<s n="s2.2;p87.114">This is to be expected, as a result of using a 0.745Hz clock instead of exactly 0.8Hz. </s>
</p>
</div2>
</div1>
<div1 type="section">
<head rend="bold">5. Generating Test Patterns</head>
<p n="p88.114">
<s n="s1.2;p88.114">As stated in 2.2.2, to make use of the scan facilities included in the design, test patterns must be produced that will highlight any potential faults. </s>
<s n="s2.2;p88.114">Although these test patterns are not required at this stage (since a faulty implementation could just be reprogrammed to the FPGA), if this circuit was to be mass produced, faults could occur and each chip would need to be tested. </s>
</p>
<div2>
<head rend="bold italic">5.1. Flip-flops</head>
<p n="p89.114">
<s n="s1.1;p89.114">All the flip-flops in the entire circuit can be tested simply, by passing through the following sequences into 'scanIn' with the circuit configured as a shift register: </s>
</p>
<list type="ordered">
<item>Fifty 0s (to reset the flip-flops, and because there are 50 in the scan chain), followed by a single 1, and then fifty more zeros.</item>
<item>Fifty 1s, a single 0, fifty 1s.</item>
<item>0110, repeated for 50 clock cycles.</item>
</list>
<p n="p90.114">
<s n="s1.2;p90.114">Each pattern should reappear at 'scanOut' unaltered. </s>
<s n="s2.2;p90.114">The first pattern tests for stuck at zero faults, the second for stuck at one faults, and the third tests flip-flop transitions. </s>
</p>
</div2>
<div2>
<head rend="bold italic">5.2. div26</head>
<p n="p91.114">
<s n="s1.2;p91.114">The 'div26' block can be tested fairly easily. </s>
<s n="s2.2;p91.114">With ScanEnable LOW and ClockSelect HIGH, the block becomes: </s>
</p>
<figure id="BAWE_6146a-fig.008"/>
<p n="p92.114">
<s n="s1.2;p92.114">In this configuration, the output of each inverter is fed back to the flip-flop from which the signal came. </s>
<s n="s2.2;p92.114">This means that a full test for the 'div26' block would be: </s>
</p>
<list type="ordered">
<item>ScanEnable = 1</item>
<item>Shift through 26 0s</item>
<item>ScanEnable = 0</item>
<item>Clock one cycle</item>
<item>ScanEnable = 1</item>
<item>After a further clock cycles, scanOut should show 26 1s (since the 0s have all been inverted).</item>
</list>
<p n="p93.114">
<s n="s1.1;p93.114">This process needs repeating with 26 1s, expected 26 0s at the output. </s>
</p>
</div2>
<div2>
<head rend="bold italic">5.3. BCD counter / Prescaler / Timing Generator</head>
<p n="p94.114">
<s n="s1.1;p94.114">The combinational logic into all 4 flip-flops and the inverter after each flip-flop must be tested. </s>
</p>
<p n="p95.114">
<s n="s1.1;p95.114">The patterns required are: </s>
</p>
<table id="BAWE_6146a-tab.003">
<row>
<cell/>
</row>
</table>
<p n="p96.114">
<s n="s1.1;p96.114">The truth tables showing the derivation of these test patterns are in Appendix E. </s>
</p>
<p n="p97.114">
<s n="s1.1;p97.114">Since the BCD counter, prescaler and timing generator all use the same logic, they all use the same test patterns. </s>
</p>
</div2>
</div1>
<div1 type="section">
<head rend="bold">6. Conclusions</head>
<div2>
<head rend="bold italic">6.1. Overview</head>
<p n="p98.114">
<s n="s1.2;p98.114">The project was completed within the allocated time, and to the specification. </s>
<s n="s2.2;p98.114">This project has been a useful introduction to the idea of designing for test, and has been an effective learning experience to become proficient with the Xilinx CAD tools. </s>
</p>
<p n="p99.114">
<s n="s1.1;p99.114">However, some problems were encountered on the way. </s>
</p>
</div2>
<div2>
<head rend="bold italic">6.2. Problems</head>
<div3>
<head rend="bold">6.2.1. Compile order</head>
<p n="p100.114">
<s n="s1.1;p100.114">While simulating the latch, the initial results were not as expected: </s>
</p>
<figure id="BAWE_6146a-pic.006">
<head>Figure 6.1 - Latch compile order problem</head>
</figure>
<p n="p101.114">
<s n="s1.1;p101.114">The compile order was identified as the problem. </s>
</p>
<p n="p102.114">
<s n="s1.5;p102.114">Before simulation takes place, the VHDL files must be compiled. </s>
<s n="s2.5;p102.114">Any code which corresponds to hierarchical blocks inside another schematic must be compiled first. </s>
<s n="s3.5;p102.114">The latch was created into a hierarchy block, and placed inside another schematic called 'overall'. </s>
<s n="s4.5;p102.114">Therefore 'latch.vhd' must be compiled before 'overall.vhd'. </s>
<s n="s5.5;p102.114">Figure 6.2 highlights where the compile order was incorrect. </s>
</p>
<figure id="BAWE_6146a-pic.007">
<head>Figure 6.2 - incorrect compile order</head>
</figure>
<p n="p103.114">
<s n="s1.1;p103.114">The correct simulation results are shown in figure 4.7. </s>
</p>
</div3>
<div3>
<head rend="bold">6.2.2. Net names</head>
<p n="p104.114">
<s n="s1.3;p104.114">Using an option in Xilinx ECS to "select line segment" caused problems at times. </s>
<s n="s2.3;p104.114">If only a segment of a wire was deleted, instead of an entire branch, the remaining segments (regardless of their size, position, or connections) would retain their net name. </s>
<s n="s3.3;p104.114">Attempting to re-use the net name resulted in an error: </s>
</p>
<figure id="BAWE_6146a-pic.008"/>
<p n="p105.114">
<s n="s1.1;p105.114">However, finding the location of the existing net (in order to remove it) was not always simple, especially during latter stages of the design. </s>
</p>
</div3>
<div3>
<head rend="bold">6.2.3. Refresh rate</head>
<p n="p106.114">
<s n="s1.2;p106.114">At first, the alternate refreshing or the 7 segment display digits was carried out by the 50Mhz clock without a scaler. </s>
<s n="s2.2;p106.114">This caused the display to not respond correctly, permanently showing symbols resembling an 8. </s>
</p>
</div3>
<div3>
<head rend="bold">6.2.4. Failed synthesis</head>
<p n="p107.114">
<s n="s1.3;p107.114">Occasionally synthesis of a design would fail, when the 'Tools... </s>
<s n="s2.3;p107.114">Check Schematic' option had failed to find bad connections. </s>
<s n="s3.3;p107.114">These issues had to be corrected by reading the synthesis report to locate the unconnected pins. </s>
</p>
</div3>
<div3>
<head rend="bold">6.2.5. Scan chain</head>
<p n="p108.114">
<s n="s1.3;p108.114">To begin with, once the circuit was functioning well as an anemometer, the scan path did not appear to work. </s>
<s n="s2.3;p108.114">There were altogether 50 flip flops, and so a single logic 1 should be passed through the scan chain to 'ScanOut' in 50 clock cycles. </s>
<s n="s3.3;p108.114">This was not the case. </s>
</p>
<p n="p109.114">
<s n="s1.1;p109.114">Intermediate scanOut LEDs were added after every hierarchical block to identify the area of the problem, which was found to be the BCD counter block. </s>
</p>
<p n="p110.114">
<s n="s1.3;p110.114">It was suspected that the timing signal going to the 'clear' input of the BCD counter was still in effect while the circuit was supposed to be configured as a scan chain. </s>
<s n="s2.3;p110.114">To disable this timing signal, a multiplexer was used on the 'clear' input of BCD counter. </s>
<s n="s3.3;p110.114">If scanSelect is 0, the clear input of the flip-flops should receive the signal from the timing generator, if 1, it should receive a logic 0 (GND). </s>
</p>
<p n="p111.114">
<s n="s1.1;p111.114">Intermediate scanOut LEDs were removed from the final schematic to cut down on output pin overhead. </s>
</p>
</div3>
</div2>
<div2>
<head rend="bold italic">6.3. Improvements</head>
<p n="p112.114">
<s n="s1.2;p112.114">Cutting down on mistakes made would have significantly reduced the time required. </s>
<s n="s2.2;p112.114">However, as a first introduction to this software and hardware environment, mistakes are only to be expected. </s>
</p>
<p n="p113.114">
<s n="s1.1;p113.114">There are many possible improvements to the functionality of the anemometer, such as: </s>
</p>
<list type="bulleted">
<item>The ability to show maximum wind speed (as opposed to current speed)</item>
<item>The ability to show average wind speed over an entire day.</item>
<item>Alerts or audible warnings if the wind reaches certain speeds.</item>
</list>
<p n="p114.114">
<s n="s1.2;p114.114">However, more important to the emphasis of this work, another test element could have been added. </s>
<s n="s2.2;p114.114">Many logic circuits today have a 'built in self-test' option, where the system will perform a different function if a fault is detected (e.g. not power on). </s>
</p>
</div2>
</div1>
</body>
<back>
<div1 type="bibliography">
<head rend="bold">7.1. Bibliography</head>
<p>
<seg type="URL" n="www.digilentinc.com"/>, "Digilent DIO4 Peripheral Board Reference Manual," 2004.</p>
<p>
<seg type="URL" n="www.digilentinc.com"/>, "Digilent D2-FT System Board Reference Manual," 2004.</p>
<p>Digilent, Inc, "D2FT to DIO4 Interconnect Tables", 2004.</p>
<p>S. Mourad and Y. Zorian, <hi rend="italic">Principles of Testing Electronic Systems</hi>: Wiley-InterScience, 2000.</p>
<p>P. N. P. Carter, "Design for Test," 2005.</p>
<p>J. B. Grimbleby, R. E. N. Horne, and S. A. Shirsavar, <hi rend="italic">EA1 Laboratory Manual</hi>: The University of Reading, 2004.</p>
<p>S. L. Linfoot, <hi rend="italic">Integrated Circuit Design and Evaluation</hi>, 2 ed: The University of Reading, 2004.</p>
<div2 type="bibliography">
<head rend="bold">7.2. References</head>
<p>[1] <seg type="URL" n="www.digilentinc.com"/>, "Digilent DIO4 Peripheral Board Reference Manual," 2004.</p>
<p>[2] <seg type="URL" n="www.digilentinc.com"/>, "Digilent D2-FT System Board Reference Manual," 2004.</p>
<p>[3] S. Mourad and Y. Zorian, <hi rend="italic">Principles of Testing Electronic Systems</hi>: Wiley-InterScience, 2000.</p>
<p>[4] P. N. P. Carter, "Design for Test," 2005.</p>
<p>[5] J. B. Grimbleby, R. E. N. Horne, and S. A. Shirsavar, <hi rend="italic">EA1 Laboratory Manual</hi>: The University of Reading, 2004.</p>
</div2>
</div1>
<div1 type="appendix">
<head rend="bold">8. Appendices</head>
<p/>
</div1>
</back>
</text>
</TEI.2>

This report details the specification, design, implementation and testing of software written to control a buggy and allow it to follow an optically marked track. The software was written in the C programming language and three variants were produced: one to allow the buggy to follow a square track - alternately clockwise and anticlockwise - one to allow it to follow a maze track and one to allow it to follow any other suitably marked track. The system performed excellently in all cases, following the track accurately and searching efficiently when the track was lost. The objective is to write software that controls a mobile buggy robot, enabling it to follow an optically marked track.
Based on the above and our knowledge of the buggy, it is possible to expand a little on how the software should be implemented. For example, if the track is lost at any point, the buggy should  'scan' to find the track again. Also, if the track is not found during this scan, the buggy should move forwards and scan again until the track is found.
After accomplishing the task of writing software to fit the above specification, two further adaptations of the specification were produced to give a total of three slightly different specifications, each applicable to a different type of board. The above specification produced a piece of software which allows the buggy to run on any board marked out in a suitable width of black tape on a white background with gaps at junctions. A further specification allows the buggy to run on a square board and another allows it to run on a maze board, as described below. The objective is to write software that controls a mobile buggy robot, enabling it to follow an optically marked track in the shape of a square with gaps at the corners. After completing a circuit of the board, the robot should turn round and follow the track in the opposite direction.
As before, if the track is lost, the buggy should scan to find the track again. If the track is not found during this scan (i.e. the buggy is at a corner) a 'corner counter' should be incremented and the buggy should move forwards and scan again to find the track. Note that the distance the buggy moves will be dictated by the size of the gaps in the board. If the corner counter is divisible by 4 (i.e. the buggy has passed a multiple of 4 corners and has therefore just completed a circuit), the buggy should rotate round through about 180   until it finds the track again and should continue following the track in the opposite direction (i.e. if it was traveling clockwise, it should turn and follow the track anticlockwise). The objective is to write software that controls a mobile buggy robot, enabling it to follow an optically marked maze track by following the left wall.
Again, if the track is lost, the buggy should scan to find the track. If the track is not found during this scan (i.e. the buggy is at a junction or dead end), it must use a 'left wall following' algorithm. It must first check to see if there is a track at 90   to its left; if not then it checks 90   to the right of this, then 90   to the right of this and finally 90   to the right of this, returning it to the original track and sending it back in the direction it came from (i.e. having reached a dead end, the buggy backtracks). Using this algorithm allows it to solve a maze providing there are no loops within the maze.
In order to design the required software, the requirements were analysed and then broken down into progressively smaller modules which could then be designed and implemented. Each board was designed then implemented before moving on to the design for the next board. This allowed techniques learnt during the implementation of one board to be applied to the design of the software for the next type of board.
For the general specification, two basic functions were required: movement and detection. Movement covers motion in all required directions (i.e. forwards, left, right and backwards). A combination of movements was required to follow the track, scan for the track when lost and react to the result of a scan. Detection covers detecting when the paths has been lost and when the path has been found during a scan. From these basic functions, it was possible to create a general method for following a track. Here, x denotes a variable whose size is dictated by the size of the gaps at junctions on the board.
It was also possible to define a scanning method which allowed the buggy to search for the line when it is lost. Here, y denotes a variable whose size is dictated by the size of the gaps between lines of track on the board. Note that the method here is a left scanner, a right scanner can also be made simply by swapping 'left' and 'right'.
From the above, it can be seen that further methods could be written to move the buggy forwards, left, right and to scan for track. These methods, however, were found to be trivial (i.e. can be done in just one or two lines of code) so separate methods were not designed or implemented.
On top of the methods described above, code was required to define the VIA and to declare and initialise global variables. This was included at the beginning of the code and was similar to the code at the beginning of buggytimertest.c.
In addition to the methods described above, a corner counter was needed to keep track of how many corners had been passed and a method to reverse the direction of travel. These additional requirements resulted in the following software design:
Carefully choosing x and y ensures that, at corners, a scan fails exactly once. Therefore, counting corners was equivalent to counting failed sweeps, greatly simplifying both design and implementation for the square board method.
The intended algorithm for using the buggy to solve a maze was a 'left wall follower'. The main reasons for this choice were that it is a nice simple way of solving a maze and also that some previous work with this algorithm had been done in another programming module (CS118). The principle is that by imagining the tracks to have 'walls' on the left and right, following round one of the walls (in this case the left one) allows the buggy eventually to get to the end of the maze. Unfortunately there was not enough time to develop a way of marking the end of the maze and making the buggy stop when it reached the end. However, the algorithm was designed and implemented to enable the buggy to follow the maze indefinitely, eventually exploring the whole of the maze.
Methods for turning 90   left and right were also needed. These were initially relatively simple but used frequently so were designed and implemented separately. However, during implementation, it was discovered that these simple methods were inappropriate. The buggy had to be manoeuvred differently to ensure the optodetector was correctly positioned at a junction. Here, w denotes a variable whose size is dictated by the size of the buggy.
Before beginning the actual coding of the software, it was important to understand how the sample code worked, and to ensure the buggy was functioning correctly. The tester program was loaded into the SWET and executed (exact details of how this was done can be found in Appendix A). The buggy functioned correctly so the buggytimertest.c code was compiled, loaded and executed. Watching the buggy 's actions, examining the code and reading the accompanying lab sheet (see Appendix A) made it easy to see which lines did what.
The next stage was deciding which method of driving the motors was best: signalling the motor drive pulse controls or using the timer. Code was copied from buggytimertest.c to develop two short programs which moved the buggy in all directions. There was a small problem at this stage as the buggy was making strange grinding noises as it moved, which had n't happened when the test program was run. It was discovered that this was due to the fact that the delay between pulsing the motors was too short so they were slipping; simply making the delay a little longer sorted this problem. Having sorted this problem, it was decided that the best way to drive the buggy was to use the timer.
During the testing, it was also discovered that simply pulsing the left or right motor was not a very good way of turning and resulted in a very large turning circle for the buggy. However, rotating one motor clockwise and the other anticlockwise provided a much tighter turning circle - the buggy pivots about the centre of its back end, rather than a wheel. This discovery was duly noted and this method was used throughout when rotation was required.
Having done the above preliminary work to understand how the buggy worked, coding of the actual software could begin. The first stage of implementation was setting up the signals on the VIA. This task was relatively simple as the sample file buggytimertest.c required very similar signals to be set up so the project software was based on this. Global variables were also declared at the beginning of the code along with the delay method. The main method was implemented next. This sets bits on the VIA appropriately, makes the timer generate a drive pulse for the motors and calls the method which allows the buggy to follow the track, move.
These lines of code (which can be seen in Appendix B) were then tested together by defining a simple move method. Copying from the (already tested) buggytimertest.c program allowed the creation of a move method which simply makes the buggy move forward. An additional delay method was also required, which was copied from buggytimertest.c too.
Having put these methods together in order, the program was compiled then loaded into the SWET. It was then executed and, as expected, the buggy moved forwards until the reset button was pressed. This showed that the code was performing correctly. The next stage was to test the optodetector and begin to implement the basic track following method described above in the general system design. A simplified version was used first to allow the method to be tested without implementing a sweep method.
This method replaced the move method which was defined to test the code. It was then tested by compiling, loading into the SWET and executing. As expected, the robot moved forwards and, when it went off the track, printed the message 'I've lost the track.' on the screen. Having tested it and shown that the code worked, it was then altered to include the additional lines required to call a sweep method and to react to the result of a sweep. A variable found was used to store whether the sweep was successful or not (i.e. if the track was found or not). Another variable, count, was also declared at the beginning to be used later in a while loop.
In order to test this piece of code, it was necessary to create a test method to act as left_sweep. It was necessary to test the response with found being both 0 and 1 so two separate methods were used. Lines were printed out using prf to allow determination of exactly which pieces of code were being executed (they are underlined above). The two left_sweep methods were defined as follows, each being substituted into the program then compiled, loaded into the SWET and executed to test whether the code functioned correctly.
The program performed as expected under both sets of circumstances. The correct lines were displayed in each execution of the code. Having tested the code and shown that it worked correctly, a proper left_sweep method was required. The code written (according to the design above) can be seen below:
This method was then substituted into the program in place of the tester left_sweep method. The whole program was then compiled, loaded into the SWET and executed. The buggy ran as expected and followed the line correctly. It was noted, however, that the buggy ran much better clockwise than anti-clockwise. This was due to the fact that when it came to a corner, although the line was to the right, it swept to the left first. It was decided that a right_sweep method should be included, along with a variable to store the result of the last sweep, i.e. if the line was found during a sweep to the left, the next sweep would be a left_sweep; if the line was found during a sweep to the right, the next sweep would be a right_sweep. The right_sweep method was implemented in the same way as the left_sweep but with the direction lines interchanged (i.e. *VIA_ORA = 0x31     *VIA_ORA = 0x32). Also, a return value of 1 was used to indicate a left_sweep should be used and a value of 2 was used to indicate a right_sweep should be used. The move method was altered to include a direction variable and to have different behaviours depending on the value of found.
The final alteration to the general board code was to add in a few lines to print out (on the terminal screen) how many unsuccessful sweeps had occurred during a run. This was useful for deciding on the size of STEPS - if there was a large number of unsuccessful sweeps in a short period of time, STEPS should be increased as the buggy was probably not moving forwards far enough after a failed sweep.
The whole program can be seen in Appendix B and is called buggy.c. It can be used on any board. It was tested (successfully) on both the square board and the general board.
The implementation of the square board software was strongly based on the general board software, which required only small alterations. Having included a 'failed sweep' counter in the general board software made counting corners very easy as, on the square board, failed sweeps represented corners. A few lines were added to check if this number was divisible by 4 (i.e. a whole circuit had been completed) and, if so, to rotate through 180  . The rotation through 180   was accomplished by doing in a sweep in the opposite direction to the corner with a very large sweep size. The modified code can be seen in the program listing.
As so much of the code was reused from the general board software, testing was relatively simple as the whole program could be tested together. The code was compiled, loaded into the SWET and executed. As expected, the buggy followed the square round for one rotation then turned round and followed back in the other direction repeatedly, until the reset button was pressed. The full program listing for buggysquare.c can be seen in Appendix B.
The final piece of software implemented was to allow the buggy to follow a maze. The first stage in this implementation was, in fact, to build the maze board as there was not an existing one. Having created a simple maze from the black tape and white board provided, software coding was started.
Like the square board software, the maze board software was heavily based on the general board software. Firstly, alterations were made to the move method. This involved altering the response to a failed sweep to make the buggy turn 90   left, then if this failed to turn 90   right until the track was found. The right_sweep method was not required so it was removed and left_sweep was renamed as just sweep.
In order to test this code, methods for turn_90_left and turn_90_right were required. However, the design for this code was so simple that it was possible to create these methods entirely from code which was already known to work. The implementation of these methods can be seen in the program listing.
This code was then compiled, loaded into the SWET and executed. As was explained in the design section, however, it was discovered that the distance the optodetector was much too large to make the rotation effective. The buggy rotated left but would be a buggy length to the left of the line at the junction so would never find the line. To remedy this situation, the second design was developed. New constants STEPSII and STEPSIII were defined and, through experimentation, new suitable values were determined as follows.
The new program (which can be seen in the program listings) was then compiled, loaded into the SWET and finally executed on the maze board. The buggy successfully followed the maze round until the reset button was pressed. The full program listing for buggymaze.c can be seen in Appendix B.

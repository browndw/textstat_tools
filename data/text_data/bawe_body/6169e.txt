A firewall is an information technology security device which is configured to permit, deny or proxy data connections. Firewalls can either be hardware or software based.
A basic task of firewall is to control traffic between computer networks with different zones of trust. Typical example is the Internet which is a zone with no trust and an internal LAN which should be a zone with high trust. Firewall solves the security problem of connecting these two networks by interposing a specially configured gateway machine between them.
The primary benefits of using a firewall are:
There are 3 base types of firewalls which can be distinguished by communication types:
Is it between single node and the network, or between two or more networks?.
Is it intercepted at the network layer, or at the application layer?.
Network layer firewalls:based on source and destination address and on number of ports and additionally, what higher-level network protocols the packet contains. Network layer firewalls tend to operate very fast and transparently to users. Also called "circuit-level" firewalls.
Application level firewalls:use various forms of proxy servers to proxy traffic instead of routing it. As it works on the application layer, it may inspect the contents of the traffic, blocking what the firewall administrator views as inappropriate content, such as certain websites, viruses, and so forth. An application layer firewall does not route traffic on the network layer. All traffic stops at the firewall which may initiate its own connections if the traffic satisfies the rules.
Hybrids:most firewalls fall into the "hybrid'' category, which do network filtering as well as some amount of application inspection. The amount changes depending on the vendor, product, protocol and version, so some level of digging and/or testing is often necessary.
Is it being tracked at the firewall or not?.
Statefull firewalls:are able to hold in memory significant attributes of each connection, from start to finish. It keeps track of the state of network connections (such as TCP streams) travelling across it. The firewall is programmed to distinguish legitimate packets for different types of connections. Only packets matching a known connection state will be allowed by the firewall, others will be rejected.
Stateless firewalls:treat each network frame or packet in isolation. Stateless firewall does not know if any given packet is part of an existing connection, is trying to establish a new connection, or is just a rogue packet.
Properly configured firewall can consist of many protective mechanisms, such as:
It is important to realize that firewall is a tool for enforcing a security policy. If all access between trusted and untrustworthy networks is not mediated by the firewall, or the firewall is enforcing an ineffective policy, the firewall is not going to provide any protection for a network. However, even a properly designed network with a properly configured firewall cannot prevent following dangers:
Malicious use of authorised services: e.g. a firewall cannot prevent someone from using an authenticated Telnet session to compromise your internal machines or from tunnelling an unauthorised protocol through another protocol.
Users not going through the firewall: A firewall can only restrict connections that go through it. It cannot protect you from people who can go around the firewall, e.g. through a dial up server behind a firewall. It also cannot prevent an internal intruder from hacking an internal system.
Social engineering: if intruders can somehow obtain password they are not authorized to have or otherwise compromise authentication mechanisms through social engineering mechanisms, the firewall wo n't stop them. For example, a hacker could call users pretending to be a system administrator and ask them for passwords to "fix some problems".
Flaws in the host operating system: A firewall is only as secure as the operating system that a firewall is installed on. There are many flaws present in operating systems that firewall cannot protect against. In all types of firewall systems, the security of the protected network depends on the security of firewall device. Someone who breaks into our gateway and can reconfigure its settings is likely to gain access to other devices on the LAN. To prevent that, firewalls are specially configured and stripped down. Typically they run a "hardened" version of the Unix or NT operating system. (Welch-Abernathy D ,2002).
Most firewalls support one or more levels of encryption. Many firewalls that support encryption will protect outgoing data by automatically encrypting it before sending to the Internet. Likewise, encryption-enabled firewalls will receive encrypted data from Internet and decrypt the data before it reaches the LAN.
Using firewall encryption one can connect geographically-dispersed networks through the Internet, as well as support remote user access through the Internet, without worrying about someone casually intercepting and reading your data. That makes an idea of virtual private network.
These are some encryption techniques used in Firewalls:
Data Encryption Standard (DES) found in 1970 's by IBM. It is the block cipher - an algorithm that takes a fixed-length string of plaintext bits and transforms it through a series of complicated operations into another ciphertext bit string of the same length. In the case of DES, the block size is 64 bits. DES also uses a symmetric key to customize the transformation, so that decryption can only be performed by those who know the particular key used to encrypt. The key has 64 bits, however only 56 of these are actually used by the algorithm. Eight bits are used exclusively for parity checking. As a result the effective key length is 56 bits. The key is randomly chosen from 72 000 000 000 000 000 numbers and is changed for every massage.
The encryption system of DES uses the Feistel function. The Feistel structure ensures that decryption and encryption are very similar processes - the only difference is that the subkeys are applied in the reverse order when decrypting. The rest of the algorithm is identical. This greatly simplifies implementation, particularly in hardware, as there is no need for separate encryption and decryption algorithms.
RC4 was designed by Ron Rivest in 1987. Although it is officially termed "Rivest Cipher 4", the RC abbreviation alternatively means "Ron 's Code". RC4, as Vernam cipher, generates a pseudorandom stream of bits which, is combined with the plaintext using XOR. Decryption is performed the same way. To generate key, the cipher makes use of a secret internal state which consists of two parts:
The permutation is initialised with a variable length key, using the key-scheduling algorithm (KSA). Once this has been completed, the stream of bits is generated using the pseudo-random generation algorithm (PRGA).
FWZ-1 designed by Checkpoint has not been opened to public analysis. This is relatively new technology which uses a 40 bit symmetric key.
A message is encrypted with a secret key derived in a secure manner from the correspondents' Diffie-Hellman keys. The Diffie-Hellman keys are authenticated by a Certificate Authority.
The TCP/IP packet headers are not encrypted, to ensure that the protocol software will correctly handle and deliver the packets. The clear text TCP/IP header is combined with the session key to encrypt the data portion of each packet, so that no two packets are encrypted with the same key. A cryptographic checksum is embedded in each packet to ensure its data integrity. (checkpoint.com).
Message-Digest algorithm 5 (MD5) was designed by Ronald Rivest in 1991 to replace an earlier hash function, MD4. It is a widely used cryptographic hash function with a 128-bit hash value. An MD5 hash is typically a 32-character hexadecimal number. Recently, a number of projects have created MD5 "look up tables" which are easily accessible online, and can be used to reverse many MD5 strings into their original meanings. MD5 processes a variable-length message into a fixed-length output of 128 bits. The input message is broken up into chunks of 512-bit blocks. The message is padded so that its length is divisible by 512. The padding works as follows: first a single bit (1) is appended to the end of the message. This is followed by as many zeros as are required to bring the length of the message up to 64 bits less than a multiple of 512. The remaining bits are filled up with a 64-bit integer representing the length of the original message.
The main MD5 algorithm operates on a 128-bit state, divided into four 32-bit words, represented A, B, C and D. These are initialized to certain fixed constants. The main algorithm then operates on each 512-bit message block in turn, each block modifying the state. The processing of a message block consists of four similar rounds. Each round is composed of 16 similar operations based on a non-linear function F, modular addition, and left rotation.
There are four possible functions F (different one is used in each round):
The original specification of Secure Hash Algorithm 1 (SHA-1) was published in 1993 and finally approved in 1995 by US government standards agency NIST (National Institute of Standards and Technology).
SHA-1 produces a 160-bit digest from a message with a maximum length of ((2 64 - 1) bits), and is based on principles similar to those used by Professor Ronald Rivest in the design of the MD4 and MD5 message digest algorithms.
IPSec (Internet Protocol Security) is a suite of protocols for securing Internet Protocol (IP) communications by encrypting and authenticating each IP packet in a data stream. IPSec also includes protocols for cryptographic key establishment.
There are two modes of IPsec operation: transport mode and tunnel mode.
In transport mode only the message of the IP packet is encrypted. It is fully-routable since the IP header is sent as plain text, however, it can not cross NAT interfaces, as this will invalidate its hash value. Transport mode is used for host-to-host communications.
In tunnel mode, the entire IP packet is encrypted. It must then be encapsulated into a new IP packet to enable routing. Tunnel mode is used for network-to-network communications or host-to-network and host-to-host communications over the Internet.
IPsec is implemented by a set of cryptographic protocols for securing packet flows and Internet key exchange. Of the former, there are two:
Authentication Header provides authentication, message and IP header integrity - and with some cryptography algorithm also non-repudiation - but it does not offer confidentiality.
Encapsulating Security Payload provides data confidentiality, message integrity, and with some cryptography algorithm also authentication.
The key exchange protocols is defined by IPsec, include the IKE (Internet Key Exchange) protocol and its successor, IKEv2.
IPsec protocols operate at the network layer of the OSI model. This makes IPsec more flexible, as it can be used for protecting both TCP and UDP-based protocols, but increases its complexity and processing overhead, as it cannot rely on TCP (layer 4 OSI model) to manage reliability and fragmentation. (Wikipedia).
In the 1980s, the International Standards Organization (ISO) began to develop its Open Systems Interconnection (OSI) reference model. In this model, a networking system is divided into seven layers. Within each layer, one or more entities implement its functionality. Each layer uses different protocols, operates on different data units and has altered functions.
Each entity interacts directly only with the layer immediately beneath it, and provides facilities for use by the layer above it. Protocols enable an entity in one host to interact with a corresponding entity at the same layer in a remote host.
Let 's have a quick view on each Layer:
The Application layer provides a means for the user to access information on the network through an application. Data processed at this level is send or received by the application used by user.
The Presentation layer transforms data to provide a standard interface for the Application layer. Appearance of data is standardised, data is compressed, encrypted and some similar operations of the presentation are done.
The Session layer establishes, manages and terminates the connections between the local and remote application. The OSI model made this layer responsible for "graceful close" of sessions, and also for massage sequencing and recovery.
The transport layer controls the reliability of a given link through flow control, segmentation/desegmentation, and error control. Some protocols are statefull and connection oriented. This means that the transport layer can keep track of the packets and retransmit those that fail. Prioritisation of services is also done here.
The Network layer provides the functional and procedural means of transferring variable length data sequences from a source to a destination while maintaining the quality of service requested by the Transport layer. This is the layer where data is fragmented into standardised packets. The Network layer performs network routing functions, and might also perform segmentation/desegmentation, and report delivery errors. The best known example of a layer 3 protocol is the Internet Protocol (IP).
The Data Link layer provides the functional and procedural means to transfer data between network units and to detect and possibly correct errors that may occur in the Physical layer. The standardised packets of the network layer are separated into MAC frames.
The Physical layer defines all the electrical and physical specifications for devices. This includes the layout of pins, voltages, and cable specifications. The major functions and services performed by the physical layer are:
The user launches his web browser, which registers a port with operating system. When he types in the address of the internet shop and confirms it by pressing "enter" a 3-way handshake starts:
At this point, both the client and server have received an acknowledgement of the connection and connection is established.
User browser shows a main page of e-shop (index.html). User chooses the products to buy by browsing the page and adding them to the basket. Finally he decides to make a payment by debit card. There is nothing at the HTTP protocol to guarantee any data confidentiality, authenticity or integrity. As soon as user types his debit card details and presses confirms them with "enter" key the data is send transport control protocol (TCP). Application layer attaches an application header (AH).
TCP as "connection" protocol establishes connection between e-shop 's web server and user 's browser to form "a live tunnel". The debit card details are broken into manageable sizes called TCP segments. Size of the segment is determined by how much the receiver (web server) can and want to accept. Data is exchanged after TCP segment is confirmed. When the protocol is agreed, the first TCP segment is encapsulated with TCP header and passed down to network layer.
Encapsulated TCP segments are encapsulated with IP header, and become IP datagrams. The IP header includes source and destination IP addresses to help with routing the datagrams to intended destination (e-shop web server). Once the encapsulation is complete the IP datagrams are passed down to data link layer.
When IP datagrams reach the data link layer they are encapsulated by the NIC with the header and become Ethernet frames. The Ethernet Frames have to be passed down to Physical Layer.
At this final stage Ethernet frames are divided into bits and send to a wire for feather routing to the web server, where all the data processing is reversed starting from Physical layer and ending at Application layer. (Ahmed I., 2006, chap. 2).
Wired Equivalent Privacy - WEP is part of the IEEE 802.11 standard. WEP uses the stream cipher RC4 for confidentiality and the CRC-32 checksum for integrity. It can be typically configured in 4 possible modes:
By default most of wireless devices have WEP turned off. Most public wireless LAN access points (i.e., airports, hotels, etc) do not enable WEP. If the Access Point does not enable WEP, the wireless clients can not use the WEP encryption.
In some base stations, it is optional whether the encryption is enforced. The WEP encrypted may be turned on, but if it is not enforced, a client without encryption with the proper SSID can still access that base station.
Standard 64-bit WEP uses a 40 bit key (or 4 40bit keys if appropriate software), combined with a 24-bit initialization vector (IV, which is created automatically by the wireless network hardware) and the RC4 traffic key. Most 802.11 hardware now supports a larger 104-bit key; this also has a 24-bit initialization vector and so it is also sometimes marketed as a 128-bit system.
A 128-bit WEP key is almost always entered by users as a string of 26 Hexadecimal characters (0-9 and A-F). Each character represents 4 bits of the key. 4    26 = 104 bits. Adding the 24-bit IV gives "128-bit WEP key".
Additionally as interesting fact a 256-bit WEP system is available from some vendors, and as with the above-mentioned system, 24 bits of that is for the I.V., leaving 232 actual bits for protection. This is typically entered as 58 Hexadecimal characters. (58    4 = 232 bits) + 24 I.V. bits = 256 bits of WEP protection. (Klaus C. W. ).
Today websites are more complex than ever, containing a lot of dynamic content making the experience for the user more enjoyable. Dynamic content is achieved through the use of web applications which can deliver different output to a user depending on their settings and needs. Dynamic websites suffer from a threat that static websites do n't, called "Cross Site Scripting" (XSS).
Most usage of XSS is benign to the local machine. Its environment of execution is restricted to certain operations known as a sandbox, so a remote user cannot force your machine through cross site scripting to reformat its hard drive just by visiting malicious web page(Andrews M. and Whittaker J. A.,2006). Often attackers will inject JavaScript, VBScript, ActiveX, HTML, or Flash into a vulnerable application to cheat a user in order to gather data from them. Everything from account hijacking, changing of user settings, cookie theft/poisoning, or false advertising is possible. More and more uses are being attacked with XSS every day.
There are three types of XSS vulnerability:
This form of XSS vulnerability has been referred to as Local cross-site scripting. With Local cross-site scripting vulnerabilities, the problem exists within a page 's client-side script itself. For instance, if a piece of JavaScript accesses a URL request parameter and uses this information to write some HTML to its own page, and this information is not encoded using HTML entities, an XSS hole will likely be present, since this written data will be re-interpreted by browsers as HTML which could include additional client-side script.
Because of the way Internet Explorer treats client-side script in objects located in the "local zone" (safe zone), an XSS hole of this kind in a local page can result in remote execution vulnerabilities. For example, if an attacker hosts a malicious website, which contains a link to a vulnerable page on a client 's local system, a script could be injected and would run with privileges of that user 's browser on their system.
This kind of cross-site scripting hole is also referred to as a non-persistent or reflected vulnerability, and is the most common type. These holes turn up when data provided by a web client is used immediately by server-side scripts to generate a page of results for that user. If invalid user supplied data is included in the resulting page without HTML encoding, this will allow client-side code to be injected into the dynamic page. A classic example of this is in site search engines: if one searches for a string which includes some HTML special characters, often the search string will be redisplayed on the result page to indicate what was searched for. If all occurrences of the search terms are not HTML entity encoded, an XSS hole will result.
This does not appear to be a serious problem since users can only inject code into their own pages. However, with a small amount of social engineering, an attacker could convince a user to follow a malicious URL which injects code into the results page, giving the attacker full access to that page 's content. Due to the general requirement of the use of some social engineering in this, many programmers have ignored these holes as not terribly important.
This type of XSS vulnerability is also referred to as a stored or persistent or second-order vulnerability and it allows the most powerful kinds of attacks. It exists when data provided to a web application by a user is first stored persistently on the server (in a database, file system, or other location), and later displayed to users in a web page without being encoded. A classic example of this is with online message boards, where users are allowed to post HTML formatted messages for other users to read.
These vulnerabilities are usually more significant than other types because attacker can inject the script just once. This could potentially hit a large number of other users with little need for social engineering or the web application could even be infected by a cross-site scripting virus.
The methods of injection can vary a great deal, and an attacker may not need to use the web application itself to exploit such a hole. Any data received by the web application (via email, system logs, etc) that can be controlled by an attacker must be encoded prior to re-display in a dynamic page, else an XSS vulnerability of this type could result.
The term Session Hijacking refers to the exploitation of a valid Session key to gain unauthorised access to information or services in a computer system. Session keys are normally randomised and encrypted to prevent session hijacking. Session hijacking is an advanced technique which exploits vulnerabilities in the TCP protocol.
Transport Layer establishes a session between network hosts. Session hijacking calls for the intruder to spy on a TCP session. The intruder can use this technique to slip commands into the security context of the original session. One common use of session hijacking is to get the system to reveal a change of password.
Of course the hacker does not manually compromise spoofed TCP segments on the fly. Session hijacking requires special tools (e.g. Juggernaut). (Casad J., 2003) For the attack to succeed, the victim must use telnet, rlogin, ftp, or any other non-encrypted TCP/IP utility. Use of SecurID card, or other token based secondary authentication is useless as protection against hijacking, as the attacker can simply wait until the user authenticates and then hijack the session. This type of attack is very common as using a session management to solve a problem of storing state in web application is very common. And when you do it incorrectly it is open to attack.
Session management works by each user having a unique identifier that travels with him during his use of a service. The point is to overtake the identifier by breaking the session management, which can be done in 3 different ways:
Session identifiers are presented to the server as hidden fields, appended to URLs, or stored in cookies. Storing the session identifiers as cookies and than passing it to the server as each page is loaded is the most common. (Andrews M. and Whittaker J. A., 2006).
Link based tricks are commonly played upon as they are relatively easy to execute. It has been noticed that these kinds of phishing attacks were extensively executed when this Internet threat was in its infancy stage.
Below is a list of some of such tricks with appropriate examples explaining how an attacker can use such links to trick the end user:
Using Strings - uses a credible sounding text string within the URL Example: This will point towards a web server hosting a fake login screen for your EBay account.
Using @ sign - this kind of syntax is normally used for websites that require some authentication. However hackers make use of this syntax to trick victims to visit a fake login page. This works on a simple concept where in the content on the left side of @ sign is ignored and the domain name or IP address on the right side of the @ sign is treated as the legitimate domain.Example:
Status Bar Tricks- The URL is so long that it can not be completely displayed in the status bar - Often combined with the @ so that the fraudulent URL is at the end and not displayed thus the victim takes it as a legitimate host and gives away his confidential info! Example: :UserSession=2f6q9uuu88312264trzzz55884495&usersoption=SecurityUpdate&StateLevel=GetFrom@61.252.126.191/verified_by_visa.html.
Similar Name Tricks- This kind of tricks uses a credible sounding, but fraudulent, domain name. These kind of tricks have been often used by attackers gaining a psychological advantage over the victimExample : ,.
URL Encoding Tricks: This kind of tricks is used to encode the URL or portions of the URL to disguise its true value using hex, or octal encoding. Often combined with the @ which can also be disguised as wellExample: %33, which translates into 220.68.214.213.
HTML Image Mapping Tricks: The URL is actually a part of an image, which uses map coordinates to define the click area and the real URL, with the Fake URL from the  tag being displayed. Here is a small code that can easily help you achieve the same-:
As soon as the uninformed victim clicks any where on the image he is taken to the web server hosting a fake login page ().
URL as button Trick: the displayed URL is contained in the text description of a Form Button. The Button itself is formatted to match the email background so that only the Button text shows. Since it s a Form statement the Fake URL does not display in the status bar of the email client. However when one brings the mouse over the button the attacker uses the mouse over HTML tag to forge the link displayed in the status bar.
URL Redirection Tricks: uses the redirection capability of a known provider to send the user to the Phishing site. - Redirection is used by many larger sites like Yahoo, MSN, & Citibank. - Example: ://.
Double Redirect Tricks - Combines the simple redirect method with a URL Masking service such as cjb.net or tinyurl.com .The Masking service assigns the user an alias for their URL.
Example: ://jne9rrfj4.CjB.neT/?uudzQYRgY1GNEnFirst sends to: and thenRedirected to: (cjb.net) Redirected to: Intended site through cjb.net redirection service The actual URL is stored at cjb.net and is accessed through the cjb.net alias. (ContentVerification.com).
E = Encryption Public Key (20000000089).
N = A very large integer (34618195959169).
M = Plaintext: "The security of an encryption system is as strong because most people rather eat liver than do mathematics!".
C = Ciphertext.
D = Decryption Private Key (4771730348713).
Write C++ or Java programme to implement the RSA encryption and decryption using the above given parameters. You must demonstrate that your programme works! Hint: You may use a text-numeric converter of your choice to convert the plaintext into numbers.
Before Encoding the message is "The security of an encryption system is as strong because most people rather eat liver than do mathematics!".
In number representation :
After Encryption.
After Decryption "The security of an encryption system is as strong because most people rather eat liver than do mathematics!".

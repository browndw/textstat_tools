This system is a program which supervises an auction environment. It contains 3 servers and several (indeterminate number) sellers and bidders. This distributed system uses the Beowulf cluster.
Each server runs on its own machine (one node in the cluster). One of the three servers is called "Root Server" because it will launch the two others and create three child processes which are used to synchronise the clock between the 3 servers (first child process), to accept connection from outside (from bidder or seller) (second child process) and the last one is the lock manager (a section below give more details about this lock manager).
So, the root server is composed by 4 processes. However only 2 tasks identifier are needed: one for the root server and the second for the lock manager. The two others processes do n't need a PVM task id (however, they have one, the same than the root server, the parent, because the fork() function copies all the parent environment to the child).
In order to create two different tasks identifier, the lock manager process has to be created before the first PVM function call. Then, the child and the parent will have different task id. However, the parent process has to know the lock manager task id for several reasons. So this communication is done via a pipe between the parent and the child process.
The root server runs on the node Beowulf4 and has to launch the two others servers via PVM on two others machines (the chosen nodes are Beowulf2 and Beowulf6).
Below is a schema which explain the architecture of the three servers,.
The root server file and the server file is the same. When the root server spawn the two others, it will add an argument called "noroot" in order to inform the new process (Server1 and Server2) that they are not root, only simple server.
Of course, each server has to know the TID of each others in order to communicate together. So, after spawning the server, each server calls a synchronisation function which the aim is to send some information from the root server to the others servers. Then the servers TIDs are sent as well as the LockManager TID.
Hence, each server knows the TID of each others and the LockManager TID, so they are able to communicate together.
Server source file is Server.c.
The bidders can do five different things. First of all, they can register with the server (any server). Then can also see every auction contained in the server, they can bind for an auction, show the auction which they have won and can see the current time (on the server).
Before communicate with the server, the bidder has to connect with one of the server (a server which is available). This is done in 2 steps. First of all the bidder send a connection request through a socket to the root server (which IP address is determined: 10.0.1.4). This socket request is treated by the child process which is called ListenOutside (in the schema above). The function name is AcceptConnectionFromOutside in the root server (function called by the child process). Then every server TID are sent to the bidder and then the socket connection closes. Knowing the TIDs, the bidder is able to communicate with the server using PVM.
Afterward the bidder has to find an available server. When this server in found, the bidder is able to communicate with only this server. More details about the connection and message passing are written in another part below (section 3.).
Bidder and seller architecture are very similar. The communication with the server is the same (connection, then find an available server, then communicate with this server). However, a seller can do only 3 things: register with the server, add an auction and see the result of its auctions.
A file which is called "structure.h" defines the data structure. These structures are used to store a seller, a bidder and an auction.
Here is the structure which defines an auction,.
Here is the structure which defines a seller,.
Here is the structure which defines a bidder,.
A list of each of these structures is defined in the server file. These lists have to be always the same on the three servers! Indeed, for example, if a server treated a new seller, it has to inform the two other servers that a new seller is created. Furthermore, a mutual exclusion on each of these lists has to be managed. So, a LockManager is created and manages it. This is explain below, in another part.
When the server is ready, it calls a function which has to receive an instruction (from another server or bidder or seller) which is sent via PVM with the tag number 1. Indeed, as we will see in all this report, when a PVM message is sent, a tag is used in order to make clear the reception buffer. So when a process waits for a message, it waits for a message which is tagged by a special number. This number is very useful to know what we have to do with this message.
So, the server waits for a message which is tagged by the number 1. This message is an instruction. When a message tagged by 1 is received, the server treats it.
Here is the list of all the instruction which can be treated by the server:
Some of these instructions are detailed in this report. So, each time the server receives one of these instructions, it will treat it by following is protocol.
As we said above, the clock synchronisation is managed by a child process which knows the TIDs of every server (except its parent). This process synchronises the server clock by sending a PVM message to every server except its parents. Indeed, synchronise its parent is not necessary because they runs on the same machine, so the current time is the same. The delay between every clock synchronisation is defined by #define CLOCK_SYNC_TIME_SET 10. This is in second. Here, it is 10 second.
As we know, an auction has to be terminated after a time which is determined by the seller (which starts the auction). Hence, each auction 's duration has to be checked every CLOCK_SYNC_TIME_SET seconds. So, one of the server has to do that when it receives the clock synchronisation. If an auction is finished, it has to close it.
Below is the clock synchronisation sequence diagram which explains how it works,.
So, the two others servers receive the current time then save it in a global variable and one of the servers receives an instruction in order to update each auction 's duration. This update decreases the auction 's duration (-1).
So, when a seller define the duration of a new auction, he will enter a number which is the number of minutes (in the real life, CLOCK_SYNC_TIME_SET would be equal to 60) and so, every minutes, the duration is decreased. However, in order to test the program, CLOCK_SYNC_TIME_SET is equal to 10.
As we said above, each data list (seller, bidder and auction) has to be the same on each server. So, after a server has modified one of these lists, it has to inform the others servers. Furthermore, in order to stay coherent, a list can be accessed by ONLY ONE server in the same time. Indeed, if a server modifies a list and another server modifies the same list in the same time, they will inform each other but one of the information will be lost. So, a mutual exclusion has to be defined. Hence, a LockManager manages it.
Every time a server wants to access to a resource (one of the three lists: seller, bidder and auction), it has to ask to the LockManager if it is allowed to access to this resource. Then if that is the case, when the server has finished with this resource, it has to inform the LockManager in order to free this resource and then, the server inform the others servers in order to synchronise the list data.
For example, a resource access looks like below,.
When mutex_enter is called, the lock manager is informed that a server wants to access to a resource. If this resource is free then the server can use it. Otherwise, the server is blocked and waits for the release of this resource. Actually, the server waits for a synchronisation. Indeed, if the resource is not free, that means a second server is using it. So, this second server will free it and then a synchronisation will be done. Afterward, the server will ask again to the LockManager if the resource is free and the answer would be positive. If two servers want to access in the same resource which is not free then they will be blocked and they will wait for the data synchronisation. Afterward, they will ask to the LockManager if the resource is free, but only one server (the first one, this is determined by chance) would be able to use it. The other one will be blocked again until the next data synchronisation.
The sequence diagram below explain the case where the resource is available. On this diagram, the resource needed is called "this resource",.
We do n't draw the sequence diagram for the case where the resource is not available, but it 's a bit similar and we can guess it easily.
So, the mutual is done by three functions: LockManager (a child process manages it), mutex_enter and mutex_exit.
In order to understand how mutex_enter and mutex_exit work, below is the code (not all the code, only the pseudo code),.
Hence, each resource is accessed by only one server in the same time and when a resource is modified by a server, the others are informed about it before to use it themselves.
As we have explained above, the seller or bidder send a connection request (via a socket) and then receives the TIDs of every server. Afterward, it has to find an available server. In order to manage it, the bidder/seller sends an instruction which is called "areyouavble" to the first server. This instruction means "Are you available" ?.
If the server is available, that means it can receive this instruction and so, can answer. Hence, if the seller/bidder receives an answer from this server, then this server is available and then the seller/bidder will communicate with this one.
If the server is not available, then it wo n't answer and after 1 second, the seller/bidder will send the same request to another server, because that means the first one is not available. If the second server is not available, the seller/bidder will ask to the last one. If the three are not available, then the seller/bidder informs the user. So, if a response is not received from a server after 1 second that means the server is not available and we have to try with another server.
The instruction "areyouavble" is send with the tag 1 (we explained above the reason).
The schema below explains this process to find an available server,.
The bidder/seller need to communicate with the server in order to have or send some information (for example, new bidder, new seller etc...). Here are explained some of possible communication.
New Bidder:
Here is the sequence diagram useful for the creation of a new bidder. This sequence diagram is the same for the creation of a new seller. However, the tag message used for the bidder is the number 18 (use for every transaction used to create a bidder) and the number used for the seller is 16 (for all the transaction used to create a seller).
In this diagram sequence, we can see the User. We show it only in this sequence diagram because it is not very important for the explanation,.
Bid for an auction:
Here is the diagram used when a bidder wants to bid for an auction,.
Add and start an auction (a seller do that):
Here is the diagram sequence used when a seller wants to add and start a new auction, (please see next page).
In these diagrams, we can see some intern action like "Add auction". Of course, these intern actions are complexes. They use the mutual exclusion to access to the different data, synchronise the data list with the others servers etc...
The others sequence diagrams (show auctions, show time etc...) are not shown here.
This program does n't manage the case where a server dies. Indeed, if a server dies, the system still works (with only 2 servers) but the dead server does n't become alive again. If the root server dies, the child process (clock synchronisation and accept connection from outside) would still work, so the root server dead is not a problem. However, if one of the two other server (the second one, on Beowulf6) dies, the system ca n't work again because this server has to manage the auction 's duration (see above).
So, I think the system depends to much on the reliability of the server. If one dies, some problem can occur and if the one on Beowulf6 dies, the system dies as well. So, that 's a problem in this program.
A real world system like ebay.com can stay alive if one of the servers dies. Furthermore, in general, more than 3 servers are available in a real system.

Cryptography is the art of sending secret messages. For thousands of years it has been used by governments, terrorists and lovers to keep their correspondence from being read; during that time it has changed the course of wars and condemned people to death. However it is only with the birth of the internet that cryptography has been used by more than a select few. Cryptography is fundamental to how we use the internet and to modern e-commerce, for example anyone who has ever bought or sold something online has had their credit card details encrypted.
Traditionally and for thousands of years people have used what is known as private-key cryptography. As is traditional in texts on cryptography I shall refer to the receiver and sender of secret messages as Alice and Bob (rather than just A and B). Suppose Bob wants to send a secret message to Alice using a private-key cryptosystem. In order to do this Alice and Bob must previously agree on an encryption/decryption method and on a key. This would typically be: a special number or phrase, a table of what to encode different letters and words as, or even the specific settings of a decryption/encryption machine such as the famous German Enigma machine used in WWII. Once these are agreed upon (secretly of course) Bob applies the encryption method using the key to the plaintext message he want to send Alice in order to get a ciphertext which he communicates to Alice. On receiving the ciphertext Alice applies the decryption method using the key to reveal the plaintext message (see fig. 1). Ideally an eavesdropper (traditionally known as Eve) who intercepted the ciphertext would find it extremely difficult (preferably impossible) to derive the original plaintext message since she will not have the required key. Ideally there will a very large number of possible keys to prevent Eve just guessing the correct one.
A simple example of a private key cryptosystem is what is known as a monoaphabetic substitution cipher; in this system each letter of the alphabet is replaced by a different letter and the resulting text forms the ciphertext. The key in this case is a table mapping each letter to its replacement. Decryption is obviously straightforward if you have this key but much harder if you do n't; although it is in fact possible by analyzing the frequency of the different letters as first described by the Arab scientist al-Kindi in the ninth century.
There is however a major problem inherent in private-key Cryptography: that of agreeing on the key itself. Alice and Bob must both have knowledge of the key before the secret message can be sent. The key needs to be agreed upon secretly and this causes both security and logistical issues. At first this was n't much of a problem: a general such as Julius Caesar could agree a key with people in Rome before heading off on campaign. But with the communications revolution of the 19 th and 20 th centuries (telegraph, radio, telephone etc.) governments and businesses needing to communicate in secret still had to courier the keys by hand, leading to huge logistical costs and potential for treachery by the couriers.
The problem of key distribution grew even more serious with the birth of modern computing and the internet. How could two people (who might be the other side of the world from each other), meeting on the internet and wishing to communicate in secret, ever hope to do so? To send a message secretly they must agree on a key, but there is no way to send this key to begin with without risking it being intercepted. Before this problem was solved modern e-commerce was impossible.
The beginnings of a solution to this problem came in 1975, from three American cryptographers: Ralf Merckle, Whitfield Diffie, and Martin Hellmann. They developed an idea known as public-key cryptography.
In this system there are two keys, a public-key and a private-key. If Bob wants to send a message to Alice, then this time Alice takes the initiative: she picks a private-key and keeps it secret even from Bob, from this she derives a second public-key in some way from the private-key and makes this public-key freely available for anyone to see and use to send her secret messages. Bob then uses Alice 's public-key to encrypt his plaintext message which he transmits to Alice. However in public-key cryptography the encryption/decryption method is designed such that while the public-key can be used for encrypting messages, only Alice 's secret private-key can be used to decrypt the ciphertext (see fig. 2).
Our eavesdropper Eve has access to both the Public Key and the ciphertext but still cannot derive the plaintext from these.
The huge advantage of this system is that there are no logistical or security issues in agreeing on a Key since the public-key can be made available to everyone; it no longer has to be a secret so can be transmitted safely on the same medium as the ciphertext will be. Such systems allow secure and practical communication over the internet.
Merckle, Diffie, and Hellmann had come up with the general concept of this system but had n't come up with a practical example. A key requirement of this system is that the public-key can be derived from the private-key easily but not vice-versa (otherwise Eve could easily convert the freely available public-key into the private-key and hence decrypt the plaintext). Mathematically what was needed was some kind on "one way function" which is "easy" to compute but with a "hard" to compute inverse. Here "easy" means computable in a reasonable amount of time (such as a few seconds) and "hard" means only computable in an unreasonable amount of time (such as a million years).
The search for a practical implementation of a public-key cryptosystem took two years. In 1977 the computer scientists Ron Rivest and Adi Shamir along with the mathematician Len Adlemen published a joint paper [1] describing what came to be known as RSA (after their initials). The basic idea is this: Alice chooses two large prime numbers p and q, she multiplies them together to get N. The "one way function" is this multiplication, multiplying p and q to get N is quick to do, but p and q can only be deduced from N by prime factorization; however this is extremely time consuming for large N (as we shall see later). The actual detail of the method is more complex and I will describe how it works in the next section before proving why it works mathematically.
Randomly choose two large prime numbers p and q independently s.t. p   q. Compute N=pq.
Compute (p-1)(q-1).
Choose an integer 1 d (p-1)(q-1) s.t. d is coprime to (p-1)(q-1) i.e. they share no prime factors.
Find a positive integer e s.t. e   d     1 (mod (p-1)(q-1) ).
We now have: {N,d} which forms the private-key and {N,e} which forms the public-key.
Here is an example (using small numbers) of how to generate the keys: I will later use these keys to encode an example message.
Take p=7, q=13. Then N=pq=91 (p-1)(q-1) = 6*12=72.
Choose d s.t. d is coprime to 72. Choose d=29.
Finding a suitable e is a bit technical but in this case e=5 is suitable since 29   5 = 145 = 1 + 2   72     1 (mod 72) so e   d     1 (mod (p-1)(q-1)) as required.
So we have: example private-key: {91,29} and example public-key: {91,5}.
Bob uses the public-key, {N,e} (made publicly available by Alice), to encrypt the message before sending it to Alice like so:
Convert the message into an integer M s.t. M N using any standard representation (for longer messages break the message into blocks and covert each into such an integer).
Compute the ciphertext C by raising to the eth power modulo N:
Suppose we want to encrypt a message represented by the number 84. Using the Public Key in our example {N,e}={91,5} :
Here M=84 so the ciphertext since since.
So our ciphertext is 28.
Alice uses the private-key, {N,d} (kept secret by Alice), to decrypt the ciphertext, C ,sent by Bob by:
Raising C to the dth power modulo N obtaining the integer Bob enciphered: M: (I will prove that this is the case later.).
Alice can then convert this number into the message from Bob by inverting whatever standard representation Bob used.
Recall our example private-key is {N,d}={91,29} and our example ciphertext is 28 so the original message should be (Of course a computer can be programmed to calculate this a lot faster than in took me to do so with pencil, paper and calculator.).
So the original message is 84. Correct!.
I have described how RSA is supposed to work and shown that it does work in a simple example. But why does it work? I will state the fact that RSA works as described above as a theorem which I will then work prove.
Given two distinct prime numbers p,q, positive integers e,d s.t. e   d     1 (mod (p-1)(q-1)) and a positive integer M  N=pq.
If, then . i.e. .
I will require the following results in order to prove this theorem:
The Fundamental Theorem of Arithmetic and elementary modular arithmetic; I will assume the reader is familiar with both of these.
I will also need to use a result from number theory known as The Euler-Fermat Theorem, proof of which was first published by the great mathematician Leonhard Euler in 1736.
First here are a few definitions:
Definition: The highest common factor (hcf) of two positive integers a and b is the largest integer which divides both a and b.
Definition: Two positive integers a and b are coprime (or relatively prime) if and only if hcf(a,b)=1. i.e. a and b share no prime factors (by FTA).
Definition Euler 's function (or Euler 's totient function), gives the number of positive integers less than n which are coprime to n. i.e. where n is a positive integer.
Note: if p is a prime number, then .
And here is a Lemma used in proving The Euler-Fermat Theorem:
Lemma (Cancellation Law) For integers a,b,c,d, with . If a   b     a   c (mod d) and a and d are coprime, then b     c (mod d). for some integer x.
So, since a and d are coprime (i.e. share no prime factors), by the FTA.
Thus, for some integer y. .
Note: if a and d are not coprime then this is not necessarily true.
Counterexample: a=5,b=5,c=3,d=10.
For all positive integers n,M s.t. n and M are coprime .
Where is Euler 's function.
Most proofs of this theorem involve quite a lot of Number Theory. But I have managed to find a very nice direct proof [2] on which the following is based.
Recall .
Consider the set { m : 0 m n, hcf(m,n)=1 }. Since there are elements in this set I can write its elements as , all distinct positive integers   n.
Since M and n are coprime, and the numbers are all relatively prime to n, the numbers are also all relatively prime to n by the FTA (since they share prime factors with n).
Claim 1: , .
Suppose s.t. .
By the Cancellation Law Lemma, , because n and M are coprime.
Contradiction with fact that are all distinct and   n.
Note: , between 0 and n s.t. for some non-negative integer x (i.e. ).
Claim 2: shares no prime factors with n (i.e. ).
Suppose did share a prime factor, t say, with n. Then the prime number t would divide both and n. i.e. . Contradiction with above.
Thus .
So, since , and , . i.e. it is one of the .
Therefore, for every i, s.t. .
And therefore, by Claim 1, .
So, given j, s.t. .
So this j is unique to this i and this i is unique to this j.
Hence: .
Let R= . Then .
Since are all relatively prime to n, R itself is relatively prime to n by the FTA.
So by the Cancellation Law Lemma.
Let p be prime, M a positive integer.
If , then .
If then M and p are coprime since they share no prime factors.
So by Euler-Fermat Theorem.
Let p=3, M=14.
Then p is prime and , .
Now I can finally prove the RSA Theorem, this proof is based on that provided by Rivest, Shamir and Adleman in their original paper [1].
Given two distinct prime numbers p,q, positive integers e,d s.t. e   d     1 (mod (p-1)(q-1)) and a positive integer M  N=pq.
If ,.
Then , . i.e. , . .
Therefore for some integer k.
And this is equal to .
I now consider two cases:
If , then (since by Fermat 's Little Theorem ) =.
If , then (trivially).
So .
Thus for all M: .
And by similar argument for q: .
So, for some integers s, t. and by FTA p|t and q|s.
Hence, sp=tq=upq=uN for some integer u.
Thus .
As required.
This concludes the mathematically rigorous part of this essay; now I will attempt to explain why RSA has proved so successful at foiling attempts to crack it.
Consider Bob 's message to Alice from the point of view of an eavesdropper (Eve). The information she has available is: the ciphertext C, and the public-key: {N,e}. Crucially Eve does not know Alice 's secret private-key: {N,d}. The quickest (publicly known) way to determine M from {C,N,e} is to factor N into its prime factors p and q. It is then easy to compute (p-1)(q-1); and d can then be derived by solving the expression (using a variation of the Euclidian Algorithm). Thus the Private Key {N,d} is known. However prime factorization of large numbers has proved to be extraordinarily time consuming. Indeed there is no known algorithm s.t. N can be factored in polynomial time, i.e. such that the time taken to factor N: for any constants c,k.
Based on the fastest algorithm known in 1977 and the fastest computers of the time Rivest, Shamir and Adleman estimated that an integer with 100 digits could be factored in 74 years and one with 200 digits in 3.8 billion years [1]. Despite which, due to the huge increase in computing speed and sheer mathematical ingenuity, on the 3 rd of December 2003 team at the German Federal Agency for Information Technology Security announced the factorization of the 174-digit number [3]: 188198812920607963838697239461650439807163563379417382700763356422988859715234665485319060606504743045317388011303396716199692321205734031879550 6569962213 0516875930 7650257059 known as RSA-576 receiving a cash prize of $10,000 from RSA Security the company set up by Rivest, Shamir and Adleman to market their patented cryptogram. It turns out that this number is in fact 398075086424064937397125500550386491199064362342526708406385189575946388957261768583317 x 4727721461074353025362230719730482246329146953020971164 59852171130520711256363590397527.
Clearly therefore, huge numbers are required for secure use of RSA. For complete security it is now recommended that N should be about 600 digits long (2048 bits).
The theoretical computer scientist Peter Shor has shown that a working quantum computer (a computer making use of quantum phenomena at the microscopic level) implementing Shor 's Algorithm could factor prime numbers fast enough that for some constant c, rendering RSA inherently insecure. However a practical quantum computer has yet to be built and it is unlikely to happen in the near future. Such speculations on the future of quantum computing and the algorithms it may be possible to run on them are beyond the scope of this essay however.
So for the near future at least, as long as you choose a large enough N, Eve wo n't be able to factorize N and read Bob 's message in that way. Could she crack it without doing so? There is no (publicly known) method for cracking RSA faster than factoring N; however it has not been proved that no such method exists. An algorithm for factoring N in polynomial time or of cracking RSA in some other way would make RSA cryptography fundamentally insecure; but in the last 28 years no-one has been successful at this and the prime factorisation problem has been worked on by many mathematicians for hundreds of years.
RSA is very secure (as long as you pick a large enough N).
Also: Do n't worry if the mathematics you are doing seems completely useless! Hundreds of years ago when mathematicians like Euler and Fermat were proving the theorems that make RSA possible, it would have been absolutely inconceivable that their work in this area of number theory, one of the purest topics in pure mathematics, could ever have any kind of practical application. Indeed as recently as 1940 the number theorist G. H. Hardy (1877-1947) wrote "...both Gauss and lesser mathematicians may be justified in rejoicing that there is one science [number theory] at any rate, and that their own, whose very remoteness from ordinary human activities should keep it gentle and clean." [8]. Hardy may not have liked Rivest, Shamir and Adleman 's sullying of his subject had he lived to see it. But I feel it is encouraging to think, while struggling with some exotic problem in some obscure corner of mathematics with no apparent relevance to "ordinary human activities"; that in hundreds of years, that someone, working in some new science that is yet to be invented, may find some kind of (currently inconceivable) application for it.

This report documents the creation of using a mobile phone to control a buggy 's move direction. The whole system can complete a coherent motion: Dial one of these five numbers (2, 4, 6, 8, 5) on the phone keyboard, the buggy will move toward the assigned direction or pause. The system couples together the GSM modem, DTMF decoder, PIC microprocessor and stepper motors on the buggy. To achieve the effective communications between them, a series of methods are designed to meet the specification. Such as the AT commands transmission in the forms of ASCII strings between the GSM modem and the PIC, which are implemented by programs. Results indicate that the remote control of a machine is exercisable and reliable.
The assigned directions are below:
GSM Global System for Mobile communications.
GPRS General Packet Radio Service.
SMS Short Message Service 3GPP The 3rd Generation Partnership Project.
IC Integrated Circuit.
CB Citizen 's Band.
OS Operating System.
DTMF Dual Tone Multiple Frequency.
PCMCIA Personal Computer Memory Card International Association.
IMEI International Mobile Equipment Identity.
EEPROM Electrically-Erasable Programmable Read-Only Memory.
ICD Interface Control Document.
PWM Pulse-Width Modulation.
A/D Analog to Digital.
AUSART Addressable Universal Asynchronous Receiver Transmitter.
I2C Inter-Integrated Circuit.
SPI Serial Peripheral Interface.
AT command Attention! Followed by commands.
ASCII American Standard Code for Information Interchange.
DC Direct current.
I/O Input/Output.
Tx/Rx Transmitter/Receiver.
TCP/IP Transmission Control Protocol/Internet Protocol.
This project has great practical value in remote control application. There are always some dangerous circumstances that people can not access into for the spot direction or control, such as the lab where is full of harmful radioactive rays. So the need for accurate and real-time remote control is necessary and demanding. Remote and intelligent control is a longtime existed but still prospecting area of interest in current research.
My project is an attempt on the remote control to a buggy by a series of communication and processor systems. It can ensure precise and quick direction alter by the instructions you give in faraway distance, which is just by pressing numbers on the digital keyboard of your mobile phone or any fixed telephone. Such an easy function seems to have, it need to go through many parts and links. There are four indispensable elements contained in the buggy, the GSM modem, the DTMF decoder, the PIC microprocessor and the driven boards with their stepper motors, which all act different but related work. To achieve the whole system 's successful target requires these parts work smoothly in their section but cooperate well with each other in the entire link.
The buggy changing its direction under the command obviously has something to do with its stepper motors inside. By changing the direction of current flowing through the winding, the pole produced by become opposite making the rotor turned. So if you give the according sequences (high or low input voltage) to the magnet pole, it is possible to realize the direction change movement.
But which direction is ordered by person? This question depends on whether the communication is good enough. The PIC microprocessor will enable the stepper motor 's move but it need to get the instruction information from another source, which is DTMF. From the project 's title, we learn that DTMF must act an important role in the system. It is true because it decodes the tone information into digital binary forms and sends them to PIC.
The tone of the number we pressed, is transmitted through the GSM wireless communication network. To connect with the GSM modem requires dialing its SIM card number first, then wait for its automatically answer by the successful AT commands stream sent by PIC through the series port. When they begin communicating, the tone of number pressed will arrive at the input of the DTMF through the speaker of the modem.
Under the condition that those links introduced above work properly, the whole system becomes a corporate one. The final target is achieved through the four parts. There are much more knowledge and details in every part. It is a communication system, while also a programmable and processing system. However, it is used for control from people to machine no matter the distance between them, which stand for the advanced applications in carrying out the human 's will and instructions.
Researching into all parts of the system then provide sufficient knowledge before starting of the effective link and proper function. From the knowledge gained the most suitable components were chosen and carried forward to the construction stage.
The Global System for Mobile Communications (GSM) is the most popular standard for mobile phones in the world. GSM service is used by over 1.5 billion people across more than 210 countries and territories. GSM differs significantly from its predecessors in that both signaling and speech channels are digital, which means that it is considered a second generation (2G) mobile phone system. GSM is an open standard which is currently developed by the 3GPP.
GSM is a cellular network, which means that mobile phones connect to it by searching for cells in the immediate vicinity. GSM networks operate at various different radio frequencies. Most GSM networks operate in the 900 MHz or 1800 MHz bands.
The network behind the GSM system seen by the customer is large and complicated in order to provide all of the services which are required. It is divided into a number of sections and these are each covered in separate articles.
All of the elements in the system combine to produce many GSM services such as voice calls and SMS.
If we talk about GSM / GPRS modem then we mean hardware modem with real RS232 interface that could be controlled by each OS (Operating System) with AT commands. A modem is needed for receiving the call and transmitting instructions through voice tone. Comparing with many GSM modems, the GSM100T of RF solutions company is considered as our optimum decision to undertake the major communication task, since it is capable of meeting the requirements appeared in project.
It is a miniature "Plug And Play" dual band GSM modem. It can be directly connected to the serial port of a desktop or notebook computer or microprocessor through the RS232 interface. A standard SIM card can be inserted in the integral card holder within the metal enclosure. It means that the number in this SIM card is also the "name" of our buggy.
The GSM modems metal casing makes it an appropriate solution for tough applications such as Telemetry, Wireless Local Loop (payphones) or as part of a fleet management system. Its small size makes it simple to integrate in a space constraint environment. The modem is supplied with power cable, other accessories available are an antenna (with 1m coax cable), RS232 connecting cable with Telephone interface, Power Supply Unit. In the project, we will fully utilize these parts, especially the RS232 connecting Y cable and the 4 PIN telephone interface. About its practicability particular details will be given together with the serials ports in the PIC microcontroller part. In general, this modem is a very proper device to implement the function of the system.
In communication, the AT-command based messages exchanged between an application and the GSM products in order to manage GSM related events or services.
AT commands can be sent through a serial link, which is set with the following default values (factory settings), take the GSM100T for example: 115200 bits per second, 8 bits data, 1 stop bit, no parity, hardware flow control.
Most dialup modems follow to a large extent the specifications of the AT Command Set, which is short for Attention and always starting with AT and ending with a . Such important characters normally should never be changed, which tells the modem that modem commands follow. With the following basic AT commands, you can make calls directly, select the dialing method (tone or pulse), control the speaker volume, and perform a number of other basic modem operations. What is important is that you must be in the command mode of your communication software to accept the AT commands because the modem is always either in the command mode or the data mode. When in data mode, commands are treated as data. But generally a new modem starts up in command mode when it is first switched on so I did n't came across this problem.
The modem initialization string consists of a series of commands. It prepares the modem for communications, setting such features as dialing mode (tone or pulse), waits, detection of the busy signal and many other settings. Newer modem communications programs reset the initializations string for users according to which menu options they have selected or according to the enabled features. Mostly, the user does not see or type these commands, or even know about them.
The command set includes commands for various phone-line manipulations, dialing and hanging up for instance. It also includes various controls to set up the modem, including a set of register commands which allowed the user to directly set the various memory locations.
Normally commands are industry standard language used to communicate with the modem, while some modem companies have their additional command sets for their product. The following is a partial list of the common AT command sets appeared in the website of modem product GSM100T.
A register is a specific physical location in memory. Normally modems have small amounts of memory onboard. This set of commands is used to enter values in a particular register (memory location). The register will be storing a particular variable (alpha-numeric information) which is utilized by the modem and communication software. For example, S7=60 instructs your computer to "Set register #7 to the value 60".
Commands may be entered from the terminal mode of most communications software packages. We use Hyper-terminal as the communication software for AT commands testing.
DTMF stands for Dual Tone Multiple Frequency. It is a tone consisting of two frequencies superimposed to each key so that it can easily be identified by a microprocessor. Individual frequencies are chosen such that it is easy to design filters and easy to transmit the tones through a telephone line having bandwidth of approximately 3.5 kHz. DTMF was not intended to be used for data transfer, it was meant to be used for sending the control signals along the telephone line. With standard decoders it is possible to send 10 beeps per second i.e., five bits per second. DTMF standard specifies 50ms tones and 600ms duration between two successive tones.
Note that the last column is not commonly seen in the telephones that we used, but telephone exchanges use them quite often. Nowadays, DTMF is used for dialing the numbers in telephones, configuring telephone exchanges etc. A CB transceiver of 2.7 MHz is normally used to send floating codes. DTMF was designed to be able to send the codes using microphone. In the project, we make use of five numbers: 2, 4, 5, 6, 8. Each beep (or digit you dial on the telephone) is composed of two concurrent frequencies, which are superimposed on amplitude. The higher of the two frequencies is normally aloud by 4dB, and this shift is termed as twist. If the twist is equal to 4dB, the higher frequency is loud by 4dB. If the lower frequency is loud, then the twist is said to be negative.
DTMF signals can be generated through using RC networks connected to a microprocessor. MT8880 is an example of a dedicated IC. But getting the latter method work is a bit difficult if high accuracy is needed. The crystal frequency needs to be sacrificed for a non standard cycle length. Hence this method is used for simple applications. Most often, a PIC micro could be used for the above purpose.
Detecting DTMF with satisfactory precision is a hard thing. Often, a dedicated IC such as MT8870 is used for this purpose. It uses two 6th order band-pass filters using switched capacitor filters and it suppresses any harmonics. Hence they can produce pretty good sine waves from distorted input. Hence it is preferred. Again microprocessors can also be used, but their application is limited.
In the project, it is necessary to use a DTMF decoder to decode the DTMF signals transmitted from the GSM "speaker" into binary numbers. Weighing all the advantages and disadvantages, we choose the MT8870D to fulfill the function among varieties of DTMF decoders. Then it sends the binary numbers from Q1~Q4 output Pins to the input ports of PIC processor. The following work is executed by the C program that was burned into PIC.
The most fundamental part of this project is the PIC microprocessor. The device we choose is 18F452, a high performance and enhanced flash microcontrollers with 10-bit A/D product in PIC family.
The PIC18F452 features a 'C' compiler friendly development environment, 256 bytes of EEPROM, Self-programming, an ICD, 2 capture/compare/PWM functions, 8 channels of 10-bit Analog-to-Digital (A/D) converter, the synchronous serial port can be configured as either 3-wire Serial Peripheral Interface (SPI   ) or the 2-wire Inter-Integrated Circuit (I  C   ) bus and Addressable Universal Asynchronous Receiver Transmitter (AUSART). All of these features make it ideal for manufacturing equipment, instrumentation and monitoring, data acquisition, power conditioning, environmental monitoring, telecom and consumer audio/video applications.
The FLASH Program Memory of 18F452 is readable, writable, and erasable during normal operation over the entire VDD range. A read from program memory is executed in one byte at a time while a write is 8 bytes at a time. Program memory is erased in blocks of 64 bytes at a time. A bulk erase operation may not be issued from user code.
Writing or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases. A value written to program memory does not need to be a valid instruction. Executing a program memory location that forms an invalid instruction results in a NOP. In the project process, the compile tool we use is a software called MPLAB. After many testing and simulation for assurance, write the program into the program memory of 18F452. This approach makes the small-sized chip becomes an absolute controller which is independent of desktop.
In order to maintain a reliable input and output, we have to make research into the I/O ports. 18F452 has five ports available. Some pins of them are multiplexed with an alternate function from the peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin. This is the point we should notice when making use of the ports. Another noteworthiness is that how many bits we are going to send through the port and the quantity of bits that the port have since some of the bits have other functions. More details about this part will be fully discussed in the design and implementation.
PORTB is an 8-bit wide, bi-directional port. The corresponding data direction register is TRISB. Setting a TRISB bit (= 1) will make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a High-Impedance mode). Clearing a TRISB bit (= 0) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).
The same is PORTC and PORTD. PORTC is multiplexed with several peripheral functions (Table 2.3.1). PORTC pins have Schmitt Trigger input buffers. When enabling peripheral functions, care should be taken in defining TRIS bits for each PORTC pin. Some peripherals override the TRIS bit to make a pin an output, while other peripherals override the TRIS bit to make a pin an input. We should refer to the corresponding peripheral section for the correct TRIS bit settings.
From the program written into the memory of PIC (attached in Appendix), we can see there is a define in the beginning of the program:
Obviously, the PORTC6 and PORTC 7 are used as transmitter and receiver of RS232 serial port, which result in that these two pins can not be used as data transfer port. Hence we just make use of the PORTC0~PORTC3 (4 bits).
In the project, PORTD acts as the input of PIC, getting the binary forms of the instruction from the output of DTMF (Q1~Q4).
Since the AT commands between GSM modem and the microcontroller is sent through serial port, it is necessary to talk about the commonly used serial port - RS232. Figure 2.3.2 shows the typical RS-232 D9-Type. (in next page).
The Figure 2.3.3 shows the interfacing between microprocessor and terminal (both are 9-pin). From the connection we notice that it is simple to understand because only by crossing link the transmit and receive pins can achieve the effective connection from source to destination.
However, in the real practical of the project, the connection between GSM100T and PIC 18F452 is a little bit different. Because the serial port of modem is 15-pin while the PIC board is 9-Pin. This problem is overcome via the use of a Y-cable, which is facilitated with the GSM modem, provides serial link and audio link to the modem.
Bipolar type stepper motor will be stressed below. Figure 2.4.1 shows the connection of this kind of stepper-motor.
When there is current flowing on the winding 1 and 2, the stator will be performed as two crossing electromagnet. It forces the permanent magnet rotor stay in such kind of angle.
While the direction of current flowing through the X winding changed, the pole produced by the X winding become opposite making the rotor turned. On the next step, the current flowing through the Y winding has been inversed to help the rotor turning another clockwise angle. Repeating this stage, the stepper-motor will turn clockwise continuous.
In an opposite way, the method of turning the stepper-motor anti-clockwise is only change the outputs sequence as shown in the Figure 2.4.3.
In this situation, the current flows on each winding in a different direction. It makes the winding change in an opposite way, which push the magnet rotor turning anti-clockwise.
Douglas W.Jones, 1995. Stepping Motor Types [online]. The University of IOWA. Available at:  [Latest accessed 25 April 2005] (PIC Circuit Gallery, Stepper Motor controller, 2002, Operation principle of stepper motor [online]. Cleveland State University. Available at: [Latest Accessed 11 Mar 2005]).
It is clear that the bipolar stepper-motor needed all the windings to be serialized into the diver circuit other than directly serialized with the power supply. Figure 2.4.4 shows the principle circuit of this kind of stepper-motor driver circuit.
This kind driver circuit is called "H Bridge". The pair of control inputs X and X' controlled the direction of current flowing through the motor winding which affected the pole created on this motor winding. When the X is logical '1' and the X' is logical '', the Q2 is off letting the Q1 turned on but the Q4 is on making the Q3 turned off. The current flows from the power supply through the Q1 and flows from the left to the right through the motor winding, then flows through D2 and Q4 down to the ground. When X is '' but X' is '1', the current flows through the Q3, from the right to the left through the motor winding and flows through the D1 and Q2 down to the ground. The difference between the directions of the current flowing through the motor winding causes the different pole created. This allows the stepper-motor doing the operation introduced above.
Here the use of the diodes must be stressed. As known to all, the winding inside the stepper-motor acts as an inductor. However, considering there is more than one winding in a stepper-motor, the pair of inductors would be like to act as a transformer. There will be surely a continually changing voltage across the winding when the circuit is on. The voltage will possibly be transformed and enlarged. This causes some serious problem to the circuit or even damage the whole circuit. After adding the diodes, the voltage at both end of the winding was clamped. It can protect the circuit from being damaged.
In practical, there are also many ICs integrated one or more "H Bridges" inside. Take L293 as an example: there are two pairs of "H Bridges" built in as shown in Figure 2.4.5.
The two windings are connected across pin 3, 6 and pin 11, 14 individually in the circuit.
The main function of every part has been discussed in the background research part. The content of this part is designing rational approaches to implement.
The connections between the PIC and stepper motor enable the instructions be transferred and carried out, which means the PIC sending the sequences to make the motor turn and generating the quantities of steps to control its pace. So the program on PIC chip should consider and cover these aspects.
Initializing procedure is done by some "include", "define" and "use" statement.
By the three "include" text from the specified file is used at this point of the compilation. The filename "18F452", "string.h" and "stdio.h" are in  so the directory with the main source file is searched last.
The options after "fuses" vary depending on the device. This directive defines what fuses should be set in the part when it is programmed. This directive does not affect the compilation but is put in the output files.
This directive affects how the compiler will generate code for input and output instructions that follow. The standard method of doing I/O will cause the compiler to generate code to make an I/O pin either input or output every time it is used. Since the port d will be used as the input from DTMF to PIC while the port b and c as output of PIC to stepper motor, the three "use" statement should appear in the beginning of program.
This sentence tells the compiler the speed of the processor and enables the use of the built-in function: delay_ms() and delay_us(). The speed here is in 20000000 cycles per second.
The functions used in the program such as "PUTS" requires #include "string.h" and the"GETC" requires #use rs232. The PIN6 and PIN 7 of port C will be used as transmit and receive port. But we will only use the low 4 bits of port C: PIN 0 to 3.
Hence, they do n't interfere with each other.
The two different delay settings will lead to different speed of straight and turning movements.
Here comes the exact program controlling the stepper-motor to turn the instructed direction and steps. To achieve this, a dummy program called "Automatic" created.
The basic principle of stepper motor was introduced in the background researchs. The sequences of four pin outputs are "0101" "1001" "1010" "0110" in clockwise turning and "0101" "0110" "1010" "1001" in anti-clockwise turning, so each four pins of PORTB and PORTC on the PIC chip are chosen to send out the sequences. These outputs are seen as Hex values should be given to the PORTB and PORTC regs., so Table 5 shows the matching between the Hex numbers with the outputs (four more pins are added for there are 8 pin in PORTB and PORTC.
To make the stepper-motor turning step by step, a "for" looped "switch" statement were used. Take clockwise turning as an example, if the current state of four pins is "0101", so the next state of four pins will be "1001" and then will be "1010"; then will be "0110". The other case is the same and they all obey the same sequence. The code first written in C language is given below:
What should be stressed is that there may some states other than the four states above which can cause problem to the program. Another "default" state was added to the bottom of the switch statements. The PIC chip executes each line of statement very fast. So there should be some delay statements enable the PIC chip wait for enough time. The delay statement was shown as follow: for(i=DELAY;i 0;i--) ;.
This statement was added in the end of each "for" loop, so the program wait for the time equals to "DELAY" cycles on each state. With the help of an "if" statement, another set of code which similar to the code above were written to let the stepper-motor go anti-clockwise. After test the program "Automatic", the behaviour of stepper-motor shows the code can control the stepper-motor turn itself successfully. The tested code was written as a function into the practical program as briefly follows:
It can be seen from this block of code there are two keywords called "nsteps" and "direction" was passed to this function by the main function. They tell the function which direction and how many steps to be taken according to the input. Obviously, the following problem need to be solved it how to link to binary numbers from the DTMF with the "nsteps" and "dir".
Up to now, the function of control has been solved by program. However, the communication between GSM and PIC still remains a problem. When the GSM receiving an incoming call, it first need to answer that call then begin other communicate. This can be realized by transferring AT commands through RS232 serial port, as introduced in background part. With the basic AT commands, we can make, answer or hang up calls directly, select the dialing method (tone or pulse), control the speaker volume, and perform a number of other basic modem operations. The only thing should note is that the modem must be set in the Command mode in which the AT commands be accepted as commands not data.
Refer to the documentation that came with the communications software Hyper-terminal for information before entering the Command mode. The modem acknowledges most commands almost immediately. As soon as you type in a command ending with the carriage return character your modem will respond with OK.
Tabulate the commands that I have tested.
As the tested examples above, we can dial to a destination by using the "ATD" command. The ATD command is used to set a voice, data or fax call. For a data or a fax or a voice call, the application sends the following ASCII string to the modem: ATD where  is the destination phone number.
We can also answer the call selectively or automatically. When the product receives a call, it sets the RingInd signal and sends the ASCII "RING" or "+CRING: " string to the application. It is testified in Hyper-terminal. Then it waits for the application to accept the call with the ATA command.
In the project, the buggy is determined to receive any incoming call. In other words, everyone can control the buggy using mobile phones with different numbers. So we can set the modem in automatic answering mode, which is S0. Now the AT command here "ATS0=" can meet the application.  is used to determine after how many rings it answers.
Since the AT commands are sent through RS232 to modem in the form of ASCII string. This can be realized by just one code: puts("ATS0=1\r\n"); // after one ring then automatic answer.
The built-in function "puts()" in 18F452 sends each character in the string out the RS232 pin using "putc()". After the string is sent a RETURN(13) and LINE-FEED(10) are sent. That 's the reason why "\r\n" is after AT commands. In general, "puts" has the same function as "printf()".
After all the programs tested and all steps settled, download the program from PC to the PIC chip in MPLAB. Then the 18F452 PIC chip becomes a powerful and small-size microcontroller on the buggy.
In this part, we have solved two major problems in implementation. They are how to answer the commander 's call and how to control the stepper motors on buggy. Holding this design philosophy, we will deal with more practical details in the following implementation session.
In the previous part, we have designed the whole system including the exact interfaces. According to the design philosophy, a figure about the whole buggy system has been drawn and given below. What we should do in this session is linking all components and realizing their function.
From the structure above, we know the function of all parts and the connection between them. First, the whole system needs a DC power supply for every component. Different device requires different voltage power supply. Refer to the data sheet, we learn that the voltage can range from 5 to 32 volts as the power for GSM100T. The PIC18F452 integrated board needs a voltage of 5V while the regulator on it can adjust the 12V to 5V. 12V also meets the two stepper motor 's requirement. The DTMF needs a 5V can be solved via connecting to the 5V source on the PIC integrated board. So after all these consideration, we choose a 12V lead acid battery which can provide stable power to all the devices on the buggy at the same time.
Second, as the major communication part, GSM modem is the first one we care about.
Above all, an external antenna is used for picking up and transferring the signals through GSM wireless network. Correctly connect the antenna to the modem as the instructions below.
The next step is installing the SIM card into the SIM card holder on the modem. The SIM card hold will come out by pressing the eject button.
Now we need to connect the modem to the external device, which will cooperate and fulfill the control function together with the modem. The external devices in the project are composed of two parts: DTMF handset socket and PIC microcontroller.
The Y-cable used in here has been introduced in the background section, which connect the 15PIN and 9PIN RS232 serial ports perfectly. There are four Pins in the DTMF 4p4c plug, while the PIN 2 which is "speaker+" will transfer the incoming voice tone feature to the DTMF input. So we only make use of PIN2. Then connect the two RS232 ports. The Y-cable divides the 15PIN on the modem into a 9PIN male and a 4PIN DTMF plug, which enable the serial communication with the 9PIN female port on the PIC integrated board.
The last step about GSM modem is connecting with the power supply to activate.
From the figure above, it is clear that the PIN 3 and 4 on the 4 PIN modem socket are power supply port. Connect the open ending of the included power cord to a DC supply and refer to the instructions for power supply requirement. Connect the connector to the modem. The modem will turn on automatically if the power supply has been correctly connected. The red status indicator on the modem will be lit when power on. After a few seconds it will go flashing slowly.
By far, we have connected the GSM modem with PIC and DTMF. The next step is connecting the DTMF with the PIC board.
MT8870D is the DTMF decoder which will be used on the buggy. It is a very small-sized chip so the breadboard in the 18F452 is big enough. Place the chip into the breadboard and find out its working circuit. According to the components and their connected PIN, link them precisely and correctly.
We will notice that the crystal must be 3.579545MHZ and the capacitors and resistance be in precise quantity. The required 5V DC voltage source can obtain by connecting to the DC voltage source on the PIC integrated board. The DTMF input has already been connected to the "speaker+" from the GSM modem. The outputs (Q1, Q2, Q3 and Q4) need to be connected to low 4 bits of PORT D on PIC, which are PIN 19, 20, 21, 22 (see in Figure 2.3.1), will act as the information input port of PIC.
Outputs of PIC are sequences of 0 and 1 which will control stepper motors by changing the current flowing directions, taking up the low 4 bits of PORT B and PORT C on PIC. According to the program and refer to the figure 4.1.1, it is easy to find that PORTB is in charge of the forward and backward stepper motor while PORTC for the leftward and rightward motor. The following step is connecting them well. The connections between drive boards and stepper motors have been done as well.
The last step for the whole system is that provide the power supply for every part. PIC, drive boards and stepper motors must be connected to the 12V lead acid battery correctly. It is vital to be careful and never be confused about the positive and negative because almost all device are using a same battery.
Now, the system is activated and starting to implement its functions. The steps below specify a whole control and implement process from the instructor to the machine.
Steps: 1. Call the number of the GSM modem (a SIM card in it) 2. Wait for the modem 's answer 3. The modem gets the AT command written in the program delivered by PIC through RS232 serial port. So it automatically answer the call, communication 1 connected 4. Press one of the five keys on the phone 's keyboard 5. The modem received the tone through GSM network and sends it to DTMF decoder through its handset 's speaker(+) output wire. Communication 2 is linked. 6. The DTMF decoder gets the tone and decodes it into binary numbers then sends them to the input port of PIC processor. Communication 3 is established. 7. The PIC processor receives these binary numbers and executes the program in itself. The expected result is sending effective control binary numbers to two stepper motors separately, which will drive the magnet rotating in proper way. 8. With the stepper motor correctly rotating, we will see the buggy moves in various directions which merely according to the number you pressed.
Note: Everyone can control this buggy by calling its number: "07798517512", no matter how far away you are from it. It does n't set a restrict caller either. When press "5", it halt the movement. Press any other 4 numbers, it activate again. You can not try to stop its performance by ending the conversation. There is no design for the "end" key, which is a defect of the system.
Tests have been done all the time, including the tests on certain parts and on the whole system. In this stage, some problems were found and necessary modifications and improvements are made.
When fixed the connection between serial port and the stepper-motor, after power on, the stepper-motor turned some steps and stopped at a position.
Analysis:
Because there was n't any operation on GSM and DTMF then, it seemed that the problem was caused by the program in the PIC chip.
Some steps movements indicate that the initializing is ok. Just the outputs of PORTB and PORTC were forced to a fixed state. Examining the program in PIC, it seems that only the "switch()" statement can cause the output to a default state. When the states of PORTB or PORTC were not any of the four states, the switch will go to default state forever. In this case, the value of PORTB and PORTC can never be one of the "0x05", "0x09", "0x0A" or "0x06".
Solution:
After finding out the problem, there are different ways of solving it. The most simplest and effective one is to change the condition vector of the "switch()" statement. Using the state of PORT as a condition, define a new variable as the state will be sensible to solve the problem. So the code was changed into:
After program the PIC chip in this program, this problem was fixed.
Sometimes the GSM did n't answer the call and sometimes it answered but ca n't get the correct decoder numbers from DTMF.
The best skill I learned from plenty of testing experiences is how to locate the place that causing the problem and separate it from the other irrespective components.
Since GSM ca n't answer the incoming call automatically, we should focus on the AT commands. It is not sure that the commands are sent through RS232 serial port. Now we need to find out whether the ASCII string being sent. When using the Hyper-terminal software, any commands that were tested in the design philosophy part worked well. The response was always a right one, including "ATS0=1" used in program. So the TX (transmit) and RX (receive) pins on the RS232 serial ports are the first object to check. According to the Pin diagram and interface introduced in the background, we found out the very pins.
In order to find the source of problem, first we check the state of these Pins when in a good communication condition with Hyper-terminal. Connect the modem with PC by serial ports. Measuring the waveform and check the values on the RX (PIN6) of 15 PIN modem and Tx (PIN3) of 9 PIN PC serial port. I found that when entering the "ATS0=1" in the keyboard, the voltage on the pin dropped from high to low, indicating that the ASCII string is sent through RS232 and accepted as AT commands.
Because since this has been done, the modem can answer any call automatically after one ring.
Disconnect the PC and modem and reconnect the PIC integrated board. Turn on the power supply and running the program, repeat the same steps as above, but the voltage value did n't change but remained high.
So it 's the problem of program in the chip definitely. But the sentence concerning with the AT commands in the whole program is just "puts ("ATS0=0\r\n")". There is no mistake in this code. The problem must be somewhere else. Then I noticed that when opening the Hyper-terminal, the system will ask you to set some value about the serial port. The default value of bits per second is 9600. However, 9600 is for GSM20 not GSM100T, which has enhanced features than GSM20. If I do n't change the 9600 to 115200 for GSM100T, even in hyper-terminal, the AT commands that I entered would return the string response: "ERROR". This suddenly reminded me of the beginning of my program that in the define code, the baud rate is 9600 as well. May be this is the main reason resulted in problems. modify it into:
After change the baud rate, the GSM modem worked immediately. This gave me a big lesson that every detail you ignored may become the failure of the whole project.
Settings made via AT commands are automatically reused by the modem until another command is received to change them, or the modem is turned off. This is why I need to reset it every time when the turning on the power supply.
Since GSM100T is more advanced, it has some extra functions, such as TCP/IP stack available for data and internet. My project here does n't need to the TCP/IP, however it brought some invisible trouble to the system.
The TCP/IP stack has a "side effect" feature, which needs the setting ATQ0. So when sending a ATQ1 in testing stage, I got a response "+CME ERROR": 600. This TCP/IP stack sometimes will enable the modem no longer send responses to AT commands or enable some unsolicited codes (e.g. +WIND, +CREG...).
I almost met with all the problems described above. It is very necessary to find some code to disable the TCP/IP stack. From a FAQ on the GSM100T product website, I got the useful methods. Two possible resolutions to this problem are:
I tried the second way and from then on not a mistake cause by the side effect of TCP/IP. It is proved to be effective. By far we have solved the problem about AT command transmitting. The modem and PIC and communicate well now. After the call was answered, the stepper motors do n't rotating as instructed when pressing numbers on the phone. The program about controlling has been proved right as we simulated the input to PIC using the switches on board to replace the DTMF decoded binary numbers and got the correct movement on both motors. So this may be related with DTMF decoder and its working circuit since we have excluded the false possibility of program in PIC.
The working circuit configuration of DTMF is connected on the breadboard of the PIC board because it is simple and clear. But after all the space on the breadboard is limited and other devices are also linked with PIC, the circuit got damaged easily, which greatly influenced the performance. For example, when carrying out the last several tests with my supervisor, the capacitor in the input of DTMF decoder dropped down without being noticed. This resulted in the buggy not working again until we found the small capacitor and fix it.
Sometimes the front parts are all OK just the stepper motors do n't turn correctly.
A good way to decide the problem exists in DTMF or in stepper motor is that connecting the output of DTMF not to stepper motors but to the LEDs on the integrated board. Because the binary numbers decoded by DTMF can be seen through the lighting of LEDs. By using this method, we found that the decoded binary numbers are right so exclude the possibility of DTMF. Double check the connection between PIC and stepper motor and found that one of five wires on the socket has broken. Weld the wire and the problem solved.
At last all big problems have been solved by different solutions and through lots of tests and analysis and the buggy can realize its function with a very slow speed. But the performance stability of this system still needs to be improved.
The full code of the program was printed later in Appendix and saved a copy in the CD attached.
The time and energy dedicated to this project over the past 7 months has certainly met and the experiences and skills I learned exceeded the original scope of project expectations. There are many challenges and commitments illustrated in this industry technical report to produce such a buggy and many risks taken in trying something new and untested to me. The final result of project is worth the effort of engaging and involving in it. In the process of trying different approaches, I gained a better understanding both on industry and academy. The big practice like this teaches me how industry works and how projects explore one after another.
However, there exist some points still needing to be improved. First, the requirement of resetting every time when the power on, which brings inconvenience to the implementation. I think a deeper research into AT commands of GSM modem can solve this problem. Hundreds of commands can meet almost all the application circumstances. Many of them are seldom noticed and used so there should be one command can solve this.
Second, based on the present function, the buggy can be made only recognize one specific controller. This requires a more advanced compare function which can be done by improving the program. Furthermore, it is also practicable to define additional parameters to the modem by AT commands that instruct the modem to perform certain functions automatically when dialing a phone number. The commands that are used to accomplish this task must be placed in the dial string prior to issuing the command.
Third, the end of every control communication must first ending with a key "5" then pressing the "hang-up" key. If the sequence is opposite, the buggy still moves according to the last command. But normally people would like to use the "hang-up" key to end everything. So this should be reconsidered in the program that making the "hang-up" key has the same function as key "5". It is hard to implement in the project is that the "hang-up" key in the keyboard does n't have a specific DTMF frequency and can not be decoded into binary numbers as the key "5" does.
Last, the movement speed of buggy can be faster by software methods, such as modifying the program. Basically we control the speed of stepper motor by changing the parameter of cycle delay. However, this method has limitation when the parameter has already been very small. Hence another approach needs to be explored to solve this problem.
In one word, there is great potential in the future development and improvement on both hardware and software in this project.

This coursework is aimed at the use of binary trees. Binary trees are similar to linked lists such as stacks but rather than having just one "next" pointer they have two, left and right, so each node has two children. The coursework requires a postfix expression, where the operator comes after the operands, to be read from an edit box and stored into a tree. This in turn can be traversed in several different ways to get the postfix, prefix and infix expressions. As a bonus it is required for the expression to be evaluated using post order traversal.
A tree is another form of storing data using pointers. It is made up of a root node, and has a certain number of children. Each child has another set of children. The children at the bottom of the tree that point to nil are called the leaf nodes. This particular tree is a binary tree; this means it has only two children. These are defined as Left child and Right child. Functions to work on the tree are required, these include: MakeEmptyTree, IsEmptyTree, Data, LChild, RChild, MakeBTree, FreeBTree.
MakeEmptyTree is self explanatory; it will create an empty binary tree, with left and right child pointing to nil. It will return the pointer to the root node. IsEmptyTree, again, is self explanatory; this will check to see whether the pointer to the root node is pointing to nil, if it is then there is an empty tree and will return a Boolean true, otherwise will return false. Data will return the data from the node at the pointer passed to it. LChild and RChild will return a pointer to the corresponding child of the node passed to it. MakeBTree will take to pointers to root nodes of separate binary trees and join them into one big binary tree with a new root node, which will hold data passed into function, and the sub trees as the left and right child. It will return the pointer to the new root node. FreeBTree will take the given pointer and dispose of the memory used. It will do this after disposing of everything underneath so as not to create memory leaks.
There are two stack structures in this program. One will hold pointers to the root nodes of trees. This will be used to build up new trees from smaller ones. The other stack will hold numbers and is used for the post order evaluation. Both contain the functions and procedures Pop, Push, IsEmpty, MakeEmpty, Readtop and Display. For the second stack the functions and procedures are the same only different names as they have to deal with a different type of stack.
Pop is used to remove the top item of data from the list, not before storing the data from this element for use. Push will insert a new element with new data at the top of the list. IsEmpty will simply see if the top pointer is pointing at nil, which if it is will indicate the list is empty. MakeEmpty will remove all items from the list and dispose of all the memory leaving just the top pointer pointing at nil. Readtop is similar to pop with the exception that it does not remove the memory; it simply reads the data from the top element.
This button should work so that, given the postfix expression, a tree will be constructed in such a way that when traversed in a selected way will produce the correct 'fix' expression. It achieves this by using a case statement on the expression individual characters. If there is a digit a new tree is created with the digit at the root node. This is then pushed onto the tree stack. If however an operator is encountered then a new binary tree with the operator at the root and the top two trees of the stack are popped and made to be the left and right child; with the resulting tree being pushed back onto the stack. After the entire string has been checked then the final tree left in the stack is the final tree, so is popped and given a pointer to the root.
All traversal follows the same principle. They all use recursion, which is when a function calls itself to be used. They include a call of itself to the left child and a call to the right child as well as a process. The process in the traversal case is to print out the data at the current node to the memo box. The only difference between the three kinds of traversal is the placement of the process statement.
Each of these traversals, due to the use of recursion, need to have base cases. So before each call to itself there is an IF statement to determine whether the next child on the relevant side is a pointer to nil; if not then will perform recursion else it will move on to next statement. Once it have completed it will begin to work its way back up through the recursion.
This button works using Post Order traversal. The only difference is the process is not the same. Instead of printing to the memo box this traversal will use a case statement to distinguish each character in the node of the tree. If it is a digit '0' to '9' then the integer equivalent will be pushed into the second stack. If an operator is selected then it will pop the top two digits form the stack and evaluate them using the operator, then push the result back onto the stack. Once the traversal is completed the remaining item in the stack will be the result, which can be popped out into a string and into the memo box.
To test this program I will approach each button individually. The build tree button will be tested by typing in expressions and after running, test it with the used of the traversal. This will also test the traversal. The traversal does not need to be tested as it is a straight forward recursion technique. But by using them on the tree created I will be able to see that they display the correct order, which will only be true if the tree is constructed correctly. The evaluate button will be tested by inputting increasingly difficult equations with the answer already calculated, thus meaning I can compare them and test to see if they are correct.
This table shows the expressions that were input and their actual answers. Also included is the Post, In and Pre order traversals which all correspond to their correct equivalents. The Evaluate answer is also included and matches the expected answer.
The following are screenshots of the program running.

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE TEI.2 SYSTEM "tei_bawe.dtd">
<TEI.2 id="_0362e" n="version 1.0">
<teiHeader>
<fileDesc>
<titleStmt>
<title>Assignment1 and Assignment2</title>
</titleStmt>
<extent/>
<publicationStmt>
<distributor>British Academic Written English (BAWE) corpus</distributor>
<availability>
<p>The British Academic Written English (BAWE) corpus was developed at the Universities of Warwick, Reading and Oxford Brookes, under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC. Subject to the rights of the these institutions in the BAWE corpus, and pursuant to the ESRC agreement, the BAWE corpus is available to researchers for research purposes PROVIDED THAT the following conditions are met:</p>
<p>1. The corpus files are not distributed in either their original form or in modified form.</p>
<p>2. The texts are used for research purposes only; they should not be reproduced in teaching materials.</p>
<p>3. The texts are not reproduced in full for a wider audience/readership, although researchers are free to quote short passages of text (up to 200 running words from any given text).</p>
<p>4. The BAWE corpus developers (contact: BAWE@warwick.ac.uk) are informed of all projects, dissertations, theses, presentations or publications arising from analysis of the corpus.</p>
<p>5. Researchers acknowledge their use of the corpus using the following form of words: "The data in this study come from the British Academic Written English (BAWE) corpus, which was developed at the Universities of Warwick, Reading and Oxford Brookes under the directorship of Hilary Nesi and Sheena Gardner (formerly of the Centre for Applied Linguistics [previously called CELTE], Warwick), Paul Thompson (Department of Applied Linguistics, Reading) and Paul Wickens (Westminster Institute of Education, Oxford Brookes), with funding from the ESRC (RES-000-23-0800)."</p>
</availability>
</publicationStmt>
<notesStmt>
<note resp="British Academic Written English (BAWE) corpus project">The document has a title page which contains:document titletitle part</note>
<note resp="British Academic Written English (BAWE) corpus project">Language used in quote: <foreign id="English">English</foreign>
</note>
<note resp="British Academic Written English (BAWE) corpus project">comment@0361fdeleted: footer: module name and number, student and page numberscomment@0361fAppendix: commented computer code</note>
</notesStmt>
<sourceDesc>
<p n="level">2</p>
<p n="date">2006-11</p>
<p n="module title">Digital Systems Design</p>
<p n="module code">ES3B2</p>
<p n="genre family">Methodology recount</p>
<p n="discipline">Engineering</p>
<p n="disciplinary group">PS</p>
<p n="grade">D</p>
<p n="number of authors">1</p>
<p n="number of words">3295</p>
<p n="number of s-units">117</p>
<p n="number of p">57</p>
<p n="number of tables">5</p>
<p n="number of figures">2</p>
<p n="number of block quotes">15</p>
<p n="number of formulae">0</p>
<p n="number of lists">3</p>
<p n="number of paragraphs formatted like lists">6</p>
<p n="abstract present">no abstract</p>
<p n="average words per s-unit">28.2</p>
<p n="average s-units per p">2.1</p>
<p n="macrotype of assignment">simple assignment</p>
</sourceDesc>
</fileDesc>
<encodingDesc>
<p>TEI P4 (documented in: BAWE.documentation.pdf)</p>
</encodingDesc>
<profileDesc>
<particDesc>
<person>
<p n="gender">f</p>
<p n="year of birth">1985</p>
<p n="first language">Gujarati</p>
<p n="education">OSA</p>
<p n="course">Meng Electronics</p>
<p n="student ID">0362</p>
</person>
</particDesc>
</profileDesc>
</teiHeader>
<text>
<front>
<titlePage>
<titlePart>THE UNIVERSITY OF <name type="university"/> School Of Engineering</titlePart>
<docTitle>
<titlePart rend="underlined bold">Digital Systems Design</titlePart>
</docTitle>
<titlePart>BY STUDENT ID: <name type="student ID"/> REPORT REFERENCE CODE: [ES3B2A1&amp;ES3B2A2] AFFLIATION: [YEAR 3 ENGINEERING]<hi rend="bold"> ES3B2- Assignment1 and Assignment2</hi> REPORT PERFORMED ON: 6 <hi rend="sup">TH</hi> November 2006</titlePart>
</titlePage>
<div1 type="toc" n="1">
<head rend="underlined bold">CONTENTS:</head>
<p/>
</div1>
</front>
<body>
<div1 type="section">
<head rend="bold">Introduction</head>
<p n="p1.57">
<s n="s1.2;p1.57">The aim of these laboratories is to provide an introduction to some of the features of a microcontroller (M16C/62) from the Mitsubishi M16C family as well as those of a program that provides an integrated development environment (IDE) for the creation and testing of application programs. </s>
<s n="s2.2;p1.57">The codes and comments are written and programmed in IAR Embedded Workshop which provided the integrated development environment required. </s>
</p>
<p n="p2.57">
<s n="s1.2;p2.57">The microcontroller had two 7 segment display devices and 3 push button switches. </s>
<s n="s2.2;p2.57">The port responsible for the segments output was port P0 and the port responsible for the enabling the LED's output was port 1. </s>
</p>
<p n="p3.57">
<s n="s1.1;p3.57">With reference from the handouts the main objective of these laboratories was to carry out the following: </s>
</p>
<list type="ordered">
<item>To study and understand how to relate Appendixes A and B to this program </item>
<item>To comment on every line of this program </item>
<item>To change the delay section of the program Assi1.c and observe the action </item>
<item>To modify the program Assi1.c to rotate continually one segment clockwise on LED 1</item>
<item>To use SW1 to stop/start the rotation of the LED1 segment in the Assi1.c program</item>
<item>To determine the missing codes required to drive the display devices to show the current value of the count as two decimal numbers ('tens and units') on LED 1 and LED 2 in Assil2.c</item>
</list>
</div1>
<div1 type="section">
<head rend="bold">Theory</head>
<p rend="bulleted" n="p4.57">
<s n="s1.1;p4.57">I used the Appendix A to determine how the two 7 segment display devices must be driven on a time-multiplexed basis and to identify the microcontroller I/O pins involved and the voltage levels required to activate both particular display device and the individual segments. </s>
</p>
<p rend="bulleted" n="p5.57">
<s n="s1.1;p5.57">I used the Appendix B to determine the special function registers associated with the I/O pins used. </s>
</p>
<p rend="bulleted" n="p6.57">
<s n="s1.1;p6.57">The Appendix C for the codes given </s>
</p>
<p rend="bulleted" n="p7.57">
<s n="s1.1;p7.57">With the knowledge I had and understanding the lectures notes I wrote the codes and comments for the programs </s>
</p>
</div1>
<div1 type="section">
<head rend="bold">Apparatus:</head>
<p n="p8.57">
<s n="s1.1;p8.57">The hardware elements featured in the laboratories were: the microcontroller input/output (I/O) ports, 7 segment display devices and push button switches. </s>
</p>
<p n="p9.57">
<s n="s1.2;p9.57">Firstly I connected the M16C Microcontroller board to a PC and powered up both boards. </s>
<s n="s2.2;p9.57">The codes and comments were written and programmed using IAR Embedded Workshop which gives integrated development environment required for creating and testing the applications. </s>
</p>
<p n="p10.57">
<s n="s1.1;p10.57">With the reference from the handouts given, the two program files Assi1.c and Assl2i.c carried out the following operations: </s>
</p>
<p n="p11.57">
<s n="s1.1;p11.57">Assi1.c- It keeps a running count (mod 10) in the LED 2 display </s>
</p>
<p n="p12.57">
<s n="s1.1;p12.57">Assil2i.c- It contained an incomplete program for the microcontroller to count (modulo 100) the number of times switch SW1 was operated and display the result. </s>
</p>
</div1>
<div1 type="section">
<head rend="bold">Working Explanation:</head>
<div2>
<p n="p13.57">
<s n="s1.3;p13.57">
<hi rend="bold">SW1 -</hi>It is drive by 5V using 10K register (R16) and has PIN20 which is connected to the microcontroller through 96 way connector CN4-A and has been assigned Port8 bit 2. </s>
<s n="s2.3;p13.57">Port 8.2 direction register is used to set the direction and port 8.2 register is used to set it low or high. </s>
<s n="s3.3;p13.57">When it is pressed it grounds the port making it active low. </s>
</p>
<figure id="BAWE_0362e-pic.001"/>
<table id="BAWE_0362e-tab.001">
<head rend="bold">Port 8 Direction Register:</head>
<row>
<cell/>
</row>
</table>
<table id="BAWE_0362e-tab.002">
<head rend="bold">Port P8 register:</head>
<row>
<cell/>
</row>
</table>
</div2>
<div2>
<p n="p14.57">
<s n="s1.1;p14.57">
<hi rend="bold">7 Segments display device-</hi> Port 0 which is a 8 bit port, is responsible for the 7 segments display and one bit is assigned to the each segment as shown below: </s>
</p>
<figure id="BAWE_0362e-pic.002"/>
<p n="p15.57">
<s n="s1.3;p15.57">Port 0 direction register is used to set the direction of the segments and Port 0 register is used to set it pulled high or low. </s>
<s n="s2.3;p15.57">Here as shown in figure, OE is always active low as it is connected to ground and according to the function of 74HC244 it displays only the active low from all the inputs. </s>
<s n="s3.3;p15.57">Here the input is the 7segments. </s>
</p>
<figure id="BAWE_0362e-pic.003"/>
</div2>
<div2>
<p n="p16.57">
<s n="s1.4;p16.57">
<hi rend="bold">LED1 &amp; 2:</hi> The connection details of the LED1 &amp; 2 and the port 1 responsible for the enabling process are as shown above. </s>
<s n="s2.4;p16.57">The LED has an Enable pin. </s>
<s n="s3.4;p16.57">This is controlled by port 1 bit 0 for LED 1 and port 1 bit 1 for LED 2. </s>
<s n="s4.4;p16.57">Port P1 direction register is used to set the direction of LED and Port P1 register is used to set it low or high. </s>
</p>
<figure id="BAWE_0362e-fig.001">
<head rend="bold">Port P1 direction register and Port0 direction register:</head>
</figure>
<figure id="BAWE_0362e-fig.002">
<head rend="bold">Port P1 register and Port P0 register:</head>
</figure>
<div3>
<head>
<hi rend="bold">Collective working of both LED and Switch</hi> :</head>
<p n="p17.57">
<s n="s1.3;p17.57">Firstly, the direction of switch SW1 is set to input. </s>
<s n="s2.3;p17.57">The port responsible for SW1 is P8.2 and by using the Port 8 direction register(mentioned above),PD8.2 is assigned 0. </s>
<s n="s3.3;p17.57">The code for this application is <hi rend="bold">PD8.2==0</hi>; </s>
</p>
<p n="p18.57">
<s n="s1.4;p18.57">Now, the direction of both LED1and LED2 has to be set to output. </s>
<s n="s2.4;p18.57">The port P1.0 is responsible for LED1 and P1.1 is responsible for LED2. </s>
<s n="s3.4;p18.57">Using the information on Port 1 direction register, PD1.0 and PD1.1 is assigned value 1. </s>
<s n="s4.4;p18.57">The codes for this application are: </s>
</p>
<quote lang="English" rend="bold">PD1.0==1; PD1.1==1;</quote>
<p n="p19.57">
<s n="s1.4;p19.57">To set the direction of 7 segments to output, PD0 is responsible. </s>
<s n="s2.4;p19.57">Here, all the 8 bits of 8 bit port has to be assigned to output. </s>
<s n="s3.4;p19.57">Also, all the port 0 directions registers of all the segments has to be assigned 1. </s>
<s n="s4.4;p19.57">This can be done by using bytes to represent all the bits of port 0. </s>
</p>
<table id="BAWE_0362e-tab.003">
<row>
<cell/>
</row>
</table>
<p n="p20.57">
<s n="s1.1;p20.57">Here, 8+4+2+1=15=F and 8+4+2+1=15=F </s>
</p>
<p n="p21.57">
<s n="s1.2;p21.57">Therefore, 0x0FF is assigned to PD0. </s>
<s n="s2.2;p21.57">The code for this application is: </s>
</p>
<quote lang="English">PD0= 0x0FF.</quote>
<p n="p22.57">
<s n="s1.1;p22.57">In order to assign a particular segment as output, that particular segment direction port register is assigned 1 and the rest are assigned 0. </s>
</p>
<p n="p23.57">
<s n="s1.2;p23.57">When SW1 is pressed, the port P8.2 is set low, (P8.2==0). </s>
<s n="s2.2;p23.57">A condition statements can be used to set the operation of LED and segment under the control of the SW1. </s>
</p>
<p n="p24.57">
<s n="s1.4;p24.57">The commands are given for the enabling of LEDs and segments, using the port register responsible for them. </s>
<s n="s2.4;p24.57">All the port registers are assigned value 1 i.e. pulled high. </s>
<s n="s3.4;p24.57">In order to display a particular segment, only that segment is pulled low i.e. assigned value 0, others are assigned 1. </s>
<s n="s4.4;p24.57">The codes for setting all ports low are: </s>
</p>
<list type="simple">
<item>
<hi rend="bold">P0=0; -</hi> for segments</item>
<item>
<hi rend="bold">P1.0=0;</hi> - for LED1</item>
<item>
<hi rend="bold">P1.1=0;</hi> - for LED2</item>
</list>
</div3>
</div2>
</div1>
<div1 type="section">
<head rend="bold">Codes Explanation:</head>
<div2>
<head rend="underlined bold">Assi1.c</head>
<quote lang="English">#define Chip_3062x - <hi rend="italic">Chip definition for full version of IAR software</hi> #include "stdio.h" #include "iom16c62.h"<hi rend="bold"> unsigned char dis_code [6] =</hi> { 0x0FE, 0x0FD, 0x0FB, 0x0F7, 0x0EF, 0x0DF}; </quote>
<p n="p25.57">
<s rend="italic" n="s1.2;p25.57">Char dis_code behaves as an array and has been assigned 6 values for the 6 segments to be displayed. </s>
<s rend="italic" n="s2.2;p25.57">In order to assign the 7 segments of LED in byte form this code were used. </s>
</p>
<p n="p26.57">
<s rend="italic" n="s1.3;p26.57">As mentioned earlier the 7 segments were assigned to 8 bit Port P0. </s>
<s rend="italic" n="s2.3;p26.57">In order to display segment 'a' the bit assigned is 0, hence P0.0 is assigned to segment a and similarly for b,c,d,e,f ports P0.1,P0.2,P0.3,P0.4,P0.5. </s>
<s rend="italic" n="s3.3;p26.57">In order to display segment 'a', P0.0 is assigned low and rest is assigned high. </s>
</p>
<table id="BAWE_0362e-tab.004">
<row>
<cell/>
</row>
</table>
<p n="p27.57">
<s rend="italic" n="s1.1;p27.57">Hence, total bits 8+4+2+1=15=F and 8+4+2=14=E </s>
</p>
<p n="p28.57">
<s rend="italic" n="s1.1;p28.57">Therefore, 0x0FE </s>
</p>
<p n="p29.57">
<s rend="italic" n="s1.1;p29.57">Respectively for b,c,d,e,f, ports P0.1,P0.2,P0.3,P0.4,P0.5 will be pulled low only. </s>
</p>
<p n="p30.57">
<s rend="italic" n="s1.1;p30.57">P0.6 and P0.7 responsible of segment 'g' and decimal point will always remain high. </s>
</p>
<p n="p31.57">
<s rend="italic" n="s1.1;p31.57">The byte are written in sequence order of the segments in order to make a rotation. </s>
</p>
<p n="p32.57">
<s n="s1.1;p32.57">int count; - <hi rend="italic">count assigned as integer and is used as a counter for the loop displaying rotation</hi> </s>
</p>
<p n="p33.57">
<s rend="bold" n="s1.1;p33.57">void wait (unsigned long delay) </s>
</p>
<p n="p34.57">
<s rend="italic" n="s1.3;p34.57">Here, the delay variable is changed from integer to long as when high values of delay were assigned it result an error. </s>
<s rend="italic" n="s2.3;p34.57">When delay value is decreased the time, the output on the LED is displayed, became shorter, resulting the result not easily recognized by eyes. </s>
<s rend="italic" n="s3.3;p34.57">Hence, high value of delay is required in order to display the result for sufficient time to observe the results. </s>
</p>
<p n="p35.57">
<s rend="italic" n="s1.1;p35.57">There is also another way of changing delay, by using another loop inside delay function which carries it on for long. </s>
</p>
<quote lang="English">{ while (delay !=0)- perform the while loop by decrease the value of delay by 1 until it is 0 delay--; - decrease the value of delay by 1 before it has been decremented } void main(void) { PD0 = 0x0FF; - As mentioned earlier in working explanation, PD0 is the port P0 direction register and it set the direction of all port 0 bits to output. PD1.0 = 1; - As mentioned earlier in working explanation, PD1.0 is the Port PD1.0 direction register and it set the direction of the LED1 enable to output. PD1.1 = 1; - As mentioned earlier in working explanation PD1.1 is the Port PD1.1 direction register and it set the direction of the LED2 enable to output. PD8.2=0; - As mentioned earlier PD8.2 is the port PD8.2 direction register and it set the direction of SW1 as input. /* Set the port bits.*/ P0 = 0x0FF; - As mentioned earlier in working explanation P0 is the Port P0 register and it set all bits of port 0 as off. Hence, all the segments are turned off. P1.0 = 1; - As mentioned earlier in working explanation P1.0 is the port P1.0 register and set port 1 bit 0 high and hence, LED1 is turned off. P1.1 = 1; - As mentioned earlier in working explanation P1.1 is the port P1.1 register and set port 1 bit 0 high and hence, LED2 is turned off. Hence, there will be no output on LED2 count = 0; - variable int count is assigned value 0 to count while (1) - to perform while loop { </quote>
<p n="p36.57">
<s rend="bold italic" n="s1.1;p36.57">The modifications to display result on LED1 by SW1 can be done in 2 ways: </s>
</p>
<p rend="ordered" n="p37.57">
<s rend="italic" n="s1.1;p37.57">displays the result when SW1 is pressed and stop when it pressed again </s>
</p>
<p rend="ordered" n="p38.57">
<s rend="italic" n="s1.1;p38.57">at the start of the program the segment rotation is displayed and when SW1 is pressed it stops the rotation until released. </s>
</p>
<p n="p39.57">
<s rend="italic" n="s1.1;p39.57">Here, the program codes and comments are written for 2nd method, although the 1st method can be perform just by changing "if(P8.2==1)" to "while (P8.2==0)",meaning perform the operation of rotation while SW1 is pressed. </s>
</p>
<quote lang="English">
<hi rend="bold"> if (P8.2==1)</hi> {- perform the loop from here to display the output on LED1</quote>
<p n="p40.57">
<s rend="italic" n="s1.4;p40.57"> As mentioned earlier, SW1 is assigned to port 8 bit 2. </s>
<s rend="italic" n="s2.4;p40.57">Hence, port 8.2. </s>
<s rend="italic" n="s3.4;p40.57">Also, assigning the register of Port P8.2 to 1, set P8.2 high. </s>
<s rend="italic" n="s4.4;p40.57">If SW1 is not pressed perform the loop displaying the output on LED1. </s>
</p>
<quote lang="English" rend="bold"> P0 = dis_code[count%6]; </quote>
<p n="p41.57">
<s rend="italic" n="s1.2;p41.57">P0, which represents the 7 segments of LED is given the value of byte codes from dis_code. </s>
<s rend="italic" n="s2.2;p41.57">In order to choose the segment to be displayed count%6 is assigned to dis_code meaning it will display the segments in sequence order they are written. </s>
</p>
<quote lang="English">
<hi rend="bold"> P1.0 = 0;-</hi> <hi rend="italic">Set LED1 enabled on, by pulling it low</hi>, <hi rend="italic">hence LED1 will display the result</hi> <hi rend="bold"> P1.1 = 1; -</hi> <hi rend="italic">Set LED2 off, by pulling it high, hence LED2 will not display the result</hi>
</quote>
<p n="p42.57">
<s rend="italic" n="s1.1;p42.57">LED1 represented by P1.0 is enabled by setting, the P1.0 ON. LED2 is set of by setting the port responsible for it OFF. Here, by keeping only LED1ON, will display the result on LED1 only. </s>
</p>
<quote lang="English" rend="bold">wait( 10000 ); - <hi rend="italic">delay function</hi>
</quote>
<p n="p43.57">
<s rend="italic" n="s1.1;p43.57">Value of the delay is changed for proper display, using wait function. </s>
</p>
<quote lang="English">
<hi rend="bold"> count++;}-</hi> <hi rend="italic">to increase the count value by 1, before it has been incremented.</hi> </quote>
<p n="p44.57">
<s rend="italic" n="s1.2;p44.57">Suppose the value of count is 2, x=count++; assigns the value 3 to x before it has been incremented. </s>
<s rend="italic" n="s2.2;p44.57">Count value is increased each time the loop is over. </s>
</p>
<quote lang="English"> }- <hi rend="italic">End of loop to display output on LED1</hi> }- <hi rend="italic">End main</hi>
</quote>
</div2>
<div2>
<head rend="underlined bold">Assl2i.c</head>
<p n="p45.57">
<s rend="bold italic" n="s1.7;p45.57">This program is written for the M16C/62 microcontroller embedded in the Mitsubishi M16C/62 development board. </s>
<s rend="bold italic" n="s2.7;p45.57">Before the lab, the program contained incomplete codes for the microcontroller to count (modulo100) he number of times push button switch SW1 is operated and display the result. </s>
<s rend="bold italic" n="s3.7;p45.57">LED1 represents tenth place and LED2 represents unit place. </s>
<s rend="bold italic" n="s4.7;p45.57">After modifications, it now displays numbers from 1 to 99 when SW1 is pressed each time. </s>
<s rend="bold italic" n="s5.7;p45.57">After reaching 99, the LEDs turn off when SW1 is pressed and once again when SW1 is pressed, it starts the count from 1 again. </s>
<s rend="bold italic" n="s6.7;p45.57">For displaying numbers from 1-9, the LED1 is switched off, as only LED2 is needed to display unit place. </s>
<s rend="bold" n="s7.7;p45.57"> </s>
</p>
<list type="simple">
<head rend="bold italic">Ports usage:</head>
<item rend="bold italic">P0- 8bit port which controls the 7 segments of the LED</item>
<item rend="bold italic">P1.0- Port1 bit 0 to enable LED1</item>
<item rend="bold italic">P1.1- Port1 bit 1 to enable LED2</item>
<item rend="bold italic">P8.2- Port8 bit 2 for push button switch SW1</item>
</list>
<quote lang="English">#define Chip_3062x - Chip definition for full version of IAR software #include "stdio.h" #include "iom16c62.h" unsigned char dis_code[10] = { 0x0C0, 0x0F9, 0x0A4, 0x0B0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x98}, </quote>
<p n="p46.57">
<s rend="italic" n="s1.3;p46.57">Define the lookup table for the LEDs in terms of bytes and helps display number '0-9' on the LEDs. </s>
<s rend="italic" n="s2.3;p46.57">Char dis_code behaves as an array and has been assigned 10 values for the 10 numbers to be displayed. </s>
<s rend="italic" n="s3.3;p46.57">In order to assign the 7 segments of LED in byte form, for each 0-9 numbers this code were used. </s>
</p>
<p n="p47.57">
<s rend="italic" n="s1.4;p47.57">As mentioned earlier the 7 segments were assigned to 8 bit Port P0. </s>
<s rend="italic" n="s2.4;p47.57">In order to display segment '0' the bit assigned are 0, 1,2,3,4,5, hence P0.0 is assigned for segment a and similarly for b,c,d,e,f ports P0.1,P0.2,P0.3,P0.4,P0.5. </s>
<s rend="italic" n="s3.4;p47.57">In order to display segment '0', all the ports responsible i.e. </s>
<s rend="italic" n="s4.4;p47.57">P0.0-P0.5 are assigned low and rest is assigned high. </s>
</p>
<table id="BAWE_0362e-tab.005">
<row>
<cell/>
</row>
</table>
<p n="p48.57">
<s rend="italic" n="s1.1;p48.57">Hence, total bits 8+4=12=C and 0 </s>
</p>
<p n="p49.57">
<s rend="italic" n="s1.1;p49.57">Therefore, 0x0C0 is the byte for displaying '0' </s>
</p>
<p n="p50.57">
<s n="s1.2;p50.57">
<hi rend="italic">Respectively for 1-9, the byte codes are</hi> 0x0F9, 0x0A4, 0x0B0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x98. </s>
<s rend="italic" n="s2.2;p50.57">The byte are written in ascending sequence order of the numbers. </s>
</p>
<quote lang="English">int count; - <hi rend="italic">count assigned as integer and is used as a counter for the loop displaying count</hi> void wait(unsigned int delay) - <hi rend="italic">Variable Delay function to help display output for sufficient time to be recognised by eyes.</hi> { while(delay != 0) - perform the while loop by decrease the value of delay by 1 until it is 0 delay--; - decrease the value of delay by 1 before it has been decremented } void main(void) { PD0 = 0x0FF; As mentioned earlier in working explanation, PD0 is the port P0 direction register and it set the direction of all port 0 bits to output PD1.0 = 1; - As mentioned earlier in working explanation, PD1.0 is the Port PD1.0 direction register and it set the direction of the LED1 enable to output. PD1.1 = 1; - As mentioned earlier in working explanation PD1.1 is the Port PD1.1 direction register and it set the direction of the LED2 enable to output. PD8.2=0; - As mentioned earlier PD8.2 is the port PD8.2 direction register and it set the direction of SW1 as input. /* Set the port bits.*/ P0 = 0x0FF; - As mentioned earlier in working explanation P0 is the Port P0 register and it set all bits of port 0 as off. Hence, all the segments are turned off. P1.0 = 1; - As mentioned earlier in working explanation P1.0 is the port P1.0 register and set port 1 bit 0 high and hence, LED1 is turned off. P1.1 = 1; - As mentioned earlier in working explanation P1.1 is the port P1.1 register and set port 1 bit 0 high and hence, LED2 is turned off. Hence, there will be no output on LED2 while (1) - to perform while loop { if (P8.2==0) perform the loop if SW1 is pressed </quote>
<p n="p51.57">
<s rend="italic" n="s1.4;p51.57">As mentioned earlier, SW1 is assigned to port 8 bit 2. </s>
<s rend="italic" n="s2.4;p51.57">Hence, port 8.2. </s>
<s rend="italic" n="s3.4;p51.57">Also, assigning the register of Port P8.2 to 0, sets P8.2 low. </s>
<s rend="italic" n="s4.4;p51.57">Hence, If SW1 is pressed perform the loop displaying the output on LED1. </s>
</p>
<quote lang="English"> { wait(10000); -delay function if(P8.2 == 0) -perform the loop if SW1 is pressed { ++count%100; - the value of count%100 is increased after it has been incremented while(P8.2 == 0) -while function to perform if SW1 is still pressed. wait(10000);- delay function if SW1 is still pressed from the while condition } }<hi rend="bold italic"> /*for displaying 'units' place*/</hi>
</quote>
<p n="p52.57">
<s rend="italic" n="s1.1;p52.57">Here, for LED2, we do not want to display 0, the counter should start from 1 hence, the following commands were used. </s>
</p>
<quote lang="English">
<hi rend="bold">if (count%100==0)</hi> <hi rend="italic">if the value of count%100=0 then set the port 0 for 7 segment device off. Otherwise follow else statement</hi> <hi rend="bold"> P0 = 0X0FF; -</hi> <hi rend="italic">Set all bit of Port 0 (all segments) off.Hence no output number is displayed when the value of count is 0.</hi> <hi rend="bold"> else</hi>{ P0 = dis_code[(count%100)%10];</quote>
<p n="p53.57">
<s rend="italic" n="s1.6;p53.57">Port 0 is given the bytes for the segment displaying numbers 0-9 through char array dis_code. </s>
<s rend="italic" n="s2.6;p53.57">The number to be displayed is operated by the value of (count%100)%10. </s>
<s rend="italic" n="s3.6;p53.57">Here, we had to use count%100 as it does not result in error when the count reaches 100. </s>
<s rend="italic" n="s4.6;p53.57">As count=100 and only count%10 is used, it gives the value 10. </s>
<s rend="italic" n="s5.6;p53.57">But we want it to start from 0 again. </s>
<s rend="italic" n="s6.6;p53.57">Hence, (count%100)%10 is used instead of count%10. </s>
</p>
<quote lang="English">
<hi rend="bold">P1.1 = 0; -</hi> <hi rend="italic">LED2 is set low and hence will be on</hi>
<hi rend="bold"> wait(100); -</hi> <hi rend="italic">delay function to display the result more sufficient time</hi>
<hi rend="bold"> P1.1 = 1; -</hi> <hi rend="italic">Set LED2 off</hi> }<hi rend="bold">
<hi rend="italic"> /*for Displaying 'tenth' place*/ </hi> if (count%100&lt;10)</hi> <hi rend="italic">- if the value of count%100&lt;10 then set the port P0 off, as we don't need LED1 ON to display numbers from 1-9.</hi> <hi rend="italic">It is ON only when the count reaches 10</hi>
<hi rend="bold"> P0 = 0x0FF; -</hi> <hi rend="italic">Set all bit of Port 0 (all segments) off.Hence no output number is displayed when the value of count is 0.</hi> <hi rend="bold"> else</hi>{ - if the value of count%100 is not less than 10 then perform the following P0 = dis_code[(count%100)/10]; Port 0 is given the bytes for the segment displaying numbers 0-9 through char array dis_code. The number to be displayed is operated by the value of (count%100)/10. P1.0 = 0; - LED1 is set low and hence will be on wait(100); - delay function to display the result more sufficient time P1.0 = 1; - Set LED1 off }<hi rend="italic">End else condition for displaying tenth place</hi> }<hi rend="italic">End if condition of when SW1 is pressed</hi> }-<hi rend="italic"> End main </hi>
</quote>
</div2>
</div1>
<div1 type="section">
<head rend="bold">Observations:</head>
<p n="p54.57">
<s n="s1.1;p54.57">When the programs were executed the results obtained was as expected. </s>
</p>
<p n="p55.57">
<s n="s1.5;p55.57">For the first assignment, there are two methods were used to show how SW1 is used to control the rotation in 2 different ways. </s>
<s n="s2.5;p55.57">The result obtained by using the 1 <hi rend="sup">st</hi> method was when SW1 was pressed only then the rotation started and when released it stopped. </s>
<s n="s3.5;p55.57">Under the 2 <hi rend="sup">nd</hi> method the rotation started when the program was executed, but when SW1 is pressed it stops the rotation and when pressed again it starts the rotation. </s>
<s n="s4.5;p55.57">In both methods, the delay function was observed and it affected the time for which the output is displayed. </s>
<s n="s5.5;p55.57">If the value of delay is more the more time the output is displayed meaning it gives sufficient time for the eyes to recognize the changes. </s>
</p>
<p n="p56.57">
<s n="s1.4;p56.57">For the 2 <hi rend="sup">nd</hi> assignment, when the program was executed it turned off both LEDs and when SW1 is pressed it, LED2 displays 0. </s>
<s n="s2.4;p56.57">Each time it is then pressed it shows the count from 0-99 on both LEDs. </s>
<s n="s3.4;p56.57">Though LED1 is set off when the count is under 10. </s>
<s n="s4.4;p56.57">When count reaches 100 it turns off both LEDs and when pressed again it starts the count from 0-99 again. </s>
</p>
</div1>
<div1 type="section">
<head rend="bold">Conclusion:</head>
<p n="p57.57">
<s n="s1.1;p57.57">From my observations, the program codes functioned as required and therefore I met all the requirement of the tasks. </s>
</p>
</div1>
</body>
<back>
<div1 type="appendix">
<head rend="bold">Appendices:</head>
<p/>
</div1>
</back>
</text>
</TEI.2>
